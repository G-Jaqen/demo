<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }

        .container-fluid {
            display: flex;
            height: 100vh;
        }

        .charts-wrapper {
            width: 70%;
            display: flex;
            flex-direction: column;
            padding: 0.3%;
        }

        .chart-container1 {
            height: 35%; /* Fixed height for chart1 */
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 1vh;
        }

        .score-chart-container {
            height: 30%; /* Fixed height for chart1 */
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 1vh;
        }

        .chart-container2 {
            flex-grow: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .chart2-title {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            font-weight: bold;
            font-size: 2rem;
            pointer-events: none;
            z-index: 10;
            background: transparent;
        }

        .panel-container {
            width: 30%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 0.3%;
            overflow-y: auto;
        }


        .modal-xxl {
            max-width: 90vw;
            width: 85vw;
        }

        .upper-histogram {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
        }

        .showNormalPattern {
            flex-direction: column;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-backdrop.show {
            opacity: 0.8;
        }

    </style>
</head>
<body>


<div class="container-fluid">
    <!-- Left Panel Section -->
    <div class="panel-container">
        <!-- Select Training Set Title -->
        <div class="p-3 bg-light border rounded small text-center d-flex flex-column justify-content-center d-none"
             id="finshSelectTrainingSet">
            <h4 class="text-dark fw-bold mb-1 fs-1">Select Training Set(s):</h4>
        </div>


        <!-- Add/Finish Training Set Btn Section -->
        <div class="d-flex gap-1 mt-2 p-1 w-100 d-none" id="addFinishTrainingSetSection">
            <button id="addTrainingSet" class="btn btn-outline-primary w-50 fs-4"
                    style="box-shadow: 0 0 8px rgba(0, 123, 255, 0.5)">Add Training Set
            </button>
            <button id="finshSelectTrainingSetBtn" class="fs-4 btn btn-outline-success w-50 mx-auto"
                    style="box-shadow: 0 0 8px rgba(40, 167, 69, 0.5);">
                Finish Selecting
            </button>
        </div>


        <!-- Mark Anomalies Title -->
        <div class="p-3 bg-light border rounded small text-center mt-2 d-flex flex-column justify-content-center d-none"
             id="markAnomaliesTitle">
            <h3 class="text-dark fw-bold mb-1 fs-1">Mark Anomalies:</h3>
        </div>


        <!-- Cancel Mislabeled Points Title -->
        <div class="p-3 bg-light border rounded small text-center d-flex flex-column justify-content-center d-none"
             id="cancelMislabeledPointsSection">
            <h4 class="text-dark fw-bold mb-1 fs-1">Are These
                <span style="color: rgba(255, 160, 0, 1); font-weight: bold;">X </span>Anomalies?</h4>
        </div>


        <div class="d-flex gap-1 mt-2 p-1 w-100 d-none" id="yesOrNoButtonsSection">
            <button id="markAsAnomaliesBtn" class="btn btn-danger fs-3 w-50">Yes, Anomalies
            </button>
            <button id="keepPointsBtn" class="btn btn-primary fs-3 w-50">No, Normal Points
            </button>
        </div>


        <!-- Stats section1 -->
        <div id="datasetStats" class="card p-2 mt-2 d-none w-100">
            <div class="card-body p-2">
                <div class="d-flex justify-content-between fs-4">
                    <div>
                        <strong>Total Data:</strong> <span class="text-success" id="totalRecords">0</span>
                    </div>
                    <div id="trainingSetRecordsText" class="d-none">
                        <strong>TrainingSet:</strong>
                        <span class="text-primary" id="trainingSetRecords">0</span>
                    </div>
                    <div id="anomalyCountText" class="d-none">
                        <strong>Anomalies:</strong>
                        <span style="color: rgba(255, 30, 0)" id="anomalyCount">0</span>
                    </div>
                </div>
            </div>
        </div>


        <!-- Stats section3 -->
        <div id="datasetStats3" class="card p-2 mt-1 d-none w-100">
            <div class="card-body p-1">
                <div class="d-flex justify-content-between fs-5">
                    <div>
                        <strong>Total Data:</strong>
                        <span class="text-success" id="totalRecords3">0</span>
                    </div>
                    <div id="trainingSetRecordsText3">
                        <strong>TrainingSet:</strong>
                        <span class="text-primary" id="trainingSetRecords3">0</span>
                    </div>
                    <div id="userMarkedAnomalies">
                        <strong>Marked Anomalies:</strong>
                        <span class="text-danger" id="userMarkedAnomaliesNum">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Stats section4: last sigma, new sigma -->
        <div id="datasetStats4" class="card p-2 mb-1 mt-1 d-none w-100 flex-wrap: wrap">
            <div class="card-body p-1 fs-5">
                <div class="d-flex justify-content-between ">
                    <div style="min-width: 40px; padding-right: 12px;">
                        <strong>Previous Anomaly Std. Dev.:</strong>
                        <span class="text-danger" id="lastSigma">0</span>
                    </div>
                    <div id="newSigmaDiv" style="min-width: 40px; padding-right: 12px;">
                        <strong>Current Anomaly Std. Dev.:</strong>
                        <span class="text-danger" id="currentSigma">0</span>
                    </div>
                    <div id="pointsToReviewDiv" style="min-width: 40px;">
                        <strong>Points to Review:</strong>
                        <span style="color: rgba(255, 160, 0, 1)" id="pointsToReview">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Show Training Set Range Section -->
        <div id="trainDatasetStats" class="card p-1 mt-2 d-none w-100">
            <div class="card-body p-1">
                <h5 class="text-center mb-2">Training Set Range: </h5>
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <strong id="trainingSetLabel">Training Set1:</strong>
                    </div>
                    <div>
                        <label for="currentTrainingSetStart"><strong>Start:</strong></label>
                        <input type="number" id="currentTrainingSetStart" class="form-control" min="0"
                               style="width: 100px; display: inline-block;" value="0">
                    </div>
                    <div>
                        <label for="currentTrainingSetEnd"><strong>End:</strong></label>
                        <input type="number" id="currentTrainingSetEnd" class="form-control" max="10000000"
                               style="width: 100px; display: inline-block;">
                    </div>
                    <button class="btn btn-primary btn-sm ms-2" id="confirmButton">Confirm</button>
                </div>
            </div>

        </div>


        <!-- Method Section -->
        <div class="marking-sections mt-2 p-2 border border-dark rounded shadow-sm d-none" id="threeMethods">
            <div class="mb-1 text-center fs-5">
                <h4>
                    Drag out an area on the lower chart
                </h4>

            </div>
            <div class="text-center">
                <button id="markSequentialAnomaliesBtn" class="btn btn-outline-danger fs-4">Mark Anomalies
                </button>
                <button id="redoSequentialAnomaliesBtn" class="btn btn-outline-secondary fs-4">Undo</button>
            </div>
        </div>


        <!-- Auto detect Section -->
        <div class="p-2 bg-light border border-dark rounded shadow-sm mt-2 text-center d-none"
             id="autoDetectSection">
            <h4 class="text-center mb-1">Mark Anomalies Automatically:</h4>
            <button id="autoDetectBtn" class="btn btn-outline-primary fs-4" data-bs-toggle="modal"
                    data-bs-target="#autoDetectAnomaliesModal">Auto Detect
            </button>
        </div>

        <!-- Auto Detect Again and Show Advanced Stats Section -->
        <div class="p-2 bg-light border border-dark rounded shadow-sm mt-1 text-center d-none"
             id="showAdvancedStatsSection">

            <button id="autoDetectAgainBtn" class="btn btn-outline-primary btn-sm" data-bs-toggle="modal"
                    data-bs-target="#autoDetectAnomaliesModal">Auto Detect Again
            </button>
            <button id="finalTestBtn" class="btn btn-warning btn-sm" data-bs-toggle="modal"
                    data-bs-target="#evaluationModal">
                Test on Testing Sets
            </button>
        </div>


        <!-- Show Normal Pattern -->
        <div id="showNormalPatternArea" class="mt-3 mb-1 w-100 showNormalPattern d-none" style="height: 30vh;">
            <div style="flex: 0 0 8%; display: flex; align-items: center; justify-content: center;">
                <h5 class="m-0 fw-bold" id="normalPatternChartTitle">Most Similar User-Marked Anomalies</h5>
            </div>
            <div id="normalPatternChart" style="flex: 0 0 92%; width: 100%;"></div>
        </div>


        <!-- Anomaly Score Distribution Histogram -->
        <div id="anomalyScoreDistributionHistogramSection" class="mt-3 mb-1 w-100 showNormalPattern d-none"
             style="height: 30vh;">
            <div style="flex: 0 0 8%; display: flex; align-items: center; justify-content: center;">
                <h5 class="m-0 fw-bold" id="normalPatternChartTitle">Anomaly Score Distribution Histogram</h5>
            </div>
            <div id="anomalyScoreDistributionHistogramChart" style="flex: 0 0 92%; width: 100%;"></div>
        </div>

    </div>

    <!-- Right Charts Section -->
    <div class="charts-wrapper">
        <div id="scoreChart" class="score-chart-container d-none"></div>
        <div id="chart1" class="chart-container1"></div>
        <div id="chart2" class="chart-container2">
        </div>
    </div>


</div>

<!-- Trigger button -->
<button type="button" class="btn btn-primary d-none" data-bs-toggle="modal" data-bs-target="#staticBackdrop"
        id="showUploadDataModal">
    Upload Data
</button>

<!-- upload dataset modal -->
<div class="modal fade" id="staticBackdrop" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1"
     aria-labelledby="staticBackdropLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="fw-bold modal-title fs-3" id="staticBackdropLabel">Upload Dataset</h5>
            </div>
            <div class="modal-body">
                <form>
                    <div class="mb-3">
                        <label for="exampleDataSelect" class="form-label fs-4">Use an Example Dataset</label>
                        <select class="form-select fs-4" id="exampleDataSelect">
                            <option value="" selected disabled>Please select</option>
                            <option value="MBA_ECG805_data.arff">MBA ECG805</option>
                            <option value="MBA_ECG805_data.arff">Demo Dataset1</option>
                            <option value="MBA_ECG805_data.arff">Demo Dataset2</option>
                            <option value="MBA_ECG805_data.arff">Demo Dataset3</option>
                            <option value="MBA_ECG805_data.arff">Demo Dataset4</option>
                        </select>
                    </div>
                    <div class="d-flex align-items-center mb-3 mt-1">
                        <hr class="flex-grow-1">
                        <span class="px-2 fs-4">or</span>
                        <hr class="flex-grow-1">
                    </div>
                    <div class="mb-3">
                        <label for="localDataInput" class="form-label fs-4">Upload Local File</label>
                        <input class="form-control" type="file" id="localDataInput" accept=".arff,.csv">
                        <button type="button" class="btn btn-primary w-100 mt-3 fs-4" id="uploadDatasetBtn">Start
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>


<!-- Auto detect modal -->
<div class="modal fade" id="autoDetectAnomaliesModal" tabindex="-1" aria-labelledby="autoDetectAnomaliesModalLabel"
     aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title fw-bold fs-4" id="autoDetectAnomaliesModalLabel">Auto Detect Anomalies</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>

            <div class="modal-body">
                <!-- Algorithm Selection Dropdown -->
                <div class="mb-3">
                    <label for="algorithmSelect" class="form-label fs-4">Select Algorithm</label>
                    <select class="form-select fs-4" id="algorithmSelect">
                        <option value="0" selected>NormA</option>
                        <option value="1">SAND</option>
                        <option value="2">DAMP</option>
                    </select>
                </div>

                <!-- NormA -->
                <div id="normaSection" class="p-3 rounded border mb-3 fs-5">
                    <div class="form-check form-switch mb-2">
                        <input class="form-check-input" type="checkbox" id="autoDetectPatternLength" checked>
                        <label class="form-check-label" for="autoDetectPatternLength">Default Parameters</label>
                    </div>
                    <div>
                        <label for="patternLengthInput" class="form-label">Pattern Length</label>
                        <input type="number" class="form-control" id="patternLengthInput"
                               placeholder="Enter pattern length manually" disabled>
                    </div>
                </div>

                <!-- SAND -->
                <div id="sandSection" class="p-3 rounded border mb-3 d-none fs-5">
                    <div class="form-check form-switch mb-2">
                        <input class="form-check-input" type="checkbox" id="autoSand" checked>
                        <label class="form-check-label" for="autoSand">Default Parameters</label>
                    </div>
                    <div class="mb-2">
                        <label for="sandSubsequenceLength" class="form-label">Subsequence Length</label>
                        <input type="number" class="form-control" id="sandSubsequenceLength"
                               placeholder="Enter subsequence length" disabled>
                    </div>
                    <div class="mb-2">
                        <label for="sandPatternLength" class="form-label">Pattern Length</label>
                        <input type="number" class="form-control" id="sandPatternLength"
                               placeholder="Enter pattern length" disabled>
                    </div>
                    <div>
                        <label for="sandK" class="form-label">k</label>
                        <input type="number" class="form-control" id="sandK" placeholder="Enter k" disabled>
                    </div>
                </div>


                <!-- DAMP -->
                <div id="dampSection" class="p-3 rounded border mb-3 d-none  fs-5">
                    <div class="form-check form-switch mb-2">
                        <input class="form-check-input" type="checkbox" id="autoDamp" checked>
                        <label class="form-check-label" for="autoDamp">Default Parameters</label>
                    </div>
                    <div class="mb-2">
                        <label for="dampM" class="form-label">m</label>
                        <input type="number" class="form-control" id="dampM" placeholder="Enter m" disabled>
                    </div>
                    <div class="mb-2">
                        <label for="dampSpIndex" class="form-label">Sp Index</label>
                        <input type="number" class="form-control" id="dampSpIndex" placeholder="Enter sp_index"
                               disabled>
                    </div>
                    <div>
                        <label for="dampXLag" class="form-label">X lag</label>
                        <input type="number" class="form-control" id="dampXLag" placeholder="Enter x_lag" disabled>
                    </div>
                </div>


                <!-- Description Text -->
                <p class="mb-2 text-center fs-5">The model automatically find other anomalies based on your labeled
                    anomalies.</p>
                <!-- Auto-Tune Button at Bottom -->
                <div class="text-center mt-3">
                    <button id="optimizeHyperparametersBtn" class="btn btn-success fs-4">Auto Detect</button>
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Progress Bar -->
<div class="modal fade" id="loadingModal" tabindex="-1" aria-hidden="true" data-bs-backdrop="static"
     data-bs-keyboard="false">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content text-center p-5" style="font-size: 1.2rem;">
            <h4 class="mb-4 fs-3">Calculating...</h4>
            <div class="progress" style="height: 30px;">
                <div id="loadingProgressBar" class="progress-bar progress-bar-striped progress-bar-animated"
                     role="progressbar" style="width: 0">0%
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Evaluation Results Modal-->
<div class="modal fade" id="evaluationModal" tabindex="-1" aria-labelledby="evaluationModalLabel"
     aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="evaluationModalLabel">Evaluation</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">

                <div id="confidenceSection">
                    <p class="text-center text-muted mb-4">
                        The distribution of marked points has stabilized. Please provide your confidence level (1-100)
                        regarding the points you have marked.
                    </p>
                    <div class="mb-3 d-flex justify-content-center">
                        <input type="number" step="0.01" min="0" max="1" class="form-control w-25 text-center"
                               id="confidenceInput" placeholder="Your Confidence">
                    </div>
                    <hr>
                    <div class="d-flex justify-content-center">
                        <button type="button" class="btn btn-primary" id="calculateThresholdBtn">
                            Calculate Threshold And Test
                        </button>
                    </div>
                </div>

                <div id="evaluationTableSection" class="table-responsive d-none">
                    <table class="table table-bordered text-center align-middle mb-0">
                        <thead class="table-light">
                        <tr>
                            <th></th>
                            <th>Precision</th>
                            <th>Recall</th>
                            <th>F1 Score</th>
                            <th>Accuracy</th>
                            <th>Threshold Value</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td id="algoName">NormA</td>
                            <td><span id="normAPrecisionScore">-</span></td>
                            <td><span id="normARecallScore">-</span></td>
                            <td><span id="normAf1Score">-</span></td>
                            <td><span id="normAAccuracyScore">-</span></td>
                            <td><span id="finalThreshold">-</span></td>
                        </tr>
                        </tbody>
                    </table>
                </div>

            </div>
        </div>
    </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"></script>
<script>
    // flags: 0: unknown, 1: anomaly, 2: normal, 3: possible mislabeled points, 4: anomaly marked by system
    // 5: unmarked anomalies
    let point_dic = {
        99: {'size': 12, 'symbol': 'circle', 'color': 'rgba(123, 31, 162, 1)'}, // for unmark (function addAnomaly layer)
        0: {'size': 4, 'symbol': 'circle', 'color': 'rgba(100, 149, 237, 0.8)'},
        1: {'size': 11, 'symbol': 'circle', 'color': 'rgba(255, 30, 0, 0.9)'},
        2: {'size': 9, 'symbol': 'circle', 'color': 'rgba(60, 179, 113, 0.9)'},
        3: {
            'size': 15, 'symbol':
                'image://data:image/svg+xml;utf8,' +
                '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32">' +
                '<line x1="3" y1="3" x2="29" y2="29" ' +
                'stroke="%23FFA000" stroke-width="8" stroke-linecap="round"/>' +
                '<line x1="29" y1="3" x2="3" y2="29" ' +
                'stroke="%23FFA000" stroke-width="8" stroke-linecap="round"/>' +
                '</svg>'
            , 'color': 'rgba(255, 160, 0, 1)'
        },
        4: {
            'size': 15, 'symbol': 'image://data:image/svg+xml;utf8,' +
                '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32">' +
                '<line x1="3" y1="3" x2="29" y2="29" ' +
                'stroke="rgba(255,120,110,1)" stroke-width="8" stroke-linecap="round"/>' +
                '<line x1="29" y1="3" x2="3" y2="29" ' +
                'stroke="rgba(255,120,110,1)" stroke-width="8" stroke-linecap="round"/>' +
                '</svg>', 'color': 'rgba(255, 120, 110, 1)'
        },
        5: {'size': 15, 'symbol': 'diamond', 'color': 'rgba(123, 31, 162, 1)'},
    }


    // 0: NormA, 1: SAND, 2: DAMP, 3: Andri
    const algorithms_dict = {
        0: {'detect_url': "{{ url_for('detect_anomalies.norm_a') }}", 'name': 'NormA'},
        1: {'detect_url': "{{ url_for('detect_anomalies.sand') }}", 'name': 'SAND'},
        2: {'detect_url': "{{ url_for('detect_anomalies.damp') }}", 'name': 'DAMP'},
        3: {'detect_url': "{{ url_for('detect_anomalies.sand') }}", 'name': 'Andri'},
    };


    let chart1, chart2, anomalyScoreChart;
    let fullData = [], flags = [], brushAreas = [], baseline = [], globalScores = [], firstMarks = [];
    let chart1Title = "Full Data Overview";
    let clickRangeScale = 1;

    // mark sequential anomalies
    let sequentialMode = false;
    let seqDragStart = null;
    let isSeqDragging = false;
    let sequentialHandlers = {};
    let markingAnomaliesStack = [], stackForRevisePossibleMislabeledPointsPhase = [];
    let currentPhase = ''; // 'SelectTrainSetsPhase', 'MarkAnomaliesPhase'


    // NormA Params:
    let norm_a_threshold = 0;
    let norm_a_normal_patterns, norm_a_weights;
    let norm_a_normal_pattern_chart = null;
    const normal_pattern_chart_backDom = document.getElementById("normalPatternChart");
    let norm_a_intersect = [];


    // anomaly score distribution histogram
    const anomalyScoreHistogramChartDom = document.getElementById('anomalyScoreDistributionHistogramChart');
    let anomalyScoreHistogramChart = null;


    // evaluation modal
    const evaModal = new bootstrap.Modal(document.getElementById('evaluationModal'));


    // temp flags
    let flags_for_canceling_marked_labels = [];
    let flags_for_marking_more_labels = [];
    let retained_points = [];


    // global variables
    let final_mu = 0;
    let final_sigma = 0;
    let currentAlgorithmName = 'NormA';
    let training_set_10th = 0; // point with score lower than this maybe mislabeled
    let lastSigma = '-';
    let currentSigma = '-';
    let pointsForReview = 0;
    let lastStep = -1;
    let process_step = -1;
    let trainingSet; // indexes of training set points
    let anomalyMus = [];
    let anomalySigmas = [];
    let anomalyWeights = [];
    let flagsCopy;
    let responseRounds = 0;
    let copied = false;


    function initCharts() {
        chart1 = echarts.init(document.getElementById("chart1"));
        chart2 = echarts.init(document.getElementById("chart2"));

        let option1 = {
            title: {
                text: 'Click An Area To Add A Training Set',
                left: "center",
                textStyle: {
                    fontSize: 36,
                    fontWeight: 'bold',
                }
            },
            toolbox: {show: false},
            xAxis: {type: "value", data: [], name: "index"},
            yAxis: {type: "value", data: [], name: "Value"},
            grid: {left: '5%', right: '5%', top: '15%', bottom: '2%', containLabel: true},
            series: [
                {
                    type: "line",
                    data: [],
                    smooth: true,
                    showAllSymbol: true,
                    animation: false,
                    progressive: 5000,
                    progressiveThreshold: 15000,
                    sampling: 'average',
                    symbol: params => {
                        const idx = params.dataIndex;
                        const f = (flags[idx] != null ? flags[idx] : 0);
                        return point_dic[f].symbol;
                    },
                    symbolSize: params => {
                        const idx = params.dataIndex;
                        const f = (flags[idx] != null ? flags[idx] : 0);
                        return point_dic[f].size;
                    },
                    itemStyle: {
                        color: params => {
                            const idx = params.dataIndex;
                            const f = (flags[idx] != null ? flags[idx] : 0);
                            return point_dic[f].color;
                        }
                    }
                },
            ],
            emphasis: {
                disabled: true
            },
            renderer: "canvas",
            brush: [
                {
                    id: 'trainingBrush',
                    xAxisIndex: 0,
                    brushType: 'lineX',
                    brushMode: 'multiple',
                    throttleType: 'debounce',
                    throttleDelay: 1,
                    transformable: false,
                    brushStyle: {
                        color: "rgba(255, 173, 177, 0.3)",
                        lineWidth: 1,
                        opacity: 0.7,
                    },
                },
                {
                    id: 'currentWindowBrush',
                    xAxisIndex: 0,
                    brushType: 'lineX',
                    brushMode: 'single',
                    throttleType: 'debounce',
                    throttleDelay: 1,
                    transformable: false,
                    brushStyle: {
                        color: "rgba(129, 216, 208, 0.7)",
                        lineWidth: 1,
                        opacity: 0.7,
                    },
                }
            ],
        };

        let option2 = {
            title: {
                text: "Training Set",
                left: "center",
                textStyle: {
                    fontSize: 36,
                    fontWeight: 'bold',
                },
            },
            toolbox: {show: false},
            xAxis: {type: "value", data: [], name: "index"},
            yAxis: {type: "value", data: [], name: "Value"},
            dataZoom: [{type: "inside"}],
            renderer: "canvas",
            tooltip: {
                trigger: "axis",
                formatter: params => {
                    const p = params[0];
                    const data = params[0].data;
                    let result = `Index: ${data[0]}<br>Value: ${data[1]}`;
                    const sum = globalScores.slice(0, 1000).reduce((a, b) => a + b, 0);
                    if (sum !== 0) {
                        result += `<br/>Anomaly score: ${globalScores[p.dataIndex].toFixed(3)}`;
                    }
                    return result;
                }
            },
            grid: {left: '5%', right: '5%', top: '9%', bottom: '2%', containLabel: true},
            series: [
                {
                    type: "line",
                    data: [],
                    smooth: true,
                    showAllSymbol: true,
                    animation: false,
                    sampling: 'lttb',
                    progressive: 5000,
                    progressiveThreshold: 15000,
                    symbol: params => {
                        const idx = params.dataIndex;
                        const f = (flags[idx] != null ? flags[idx] : 0);
                        return point_dic[f].symbol;
                    },
                    symbolSize: params => {
                        const idx = params.dataIndex;
                        const f = (flags[idx] != null ? flags[idx] : 0);
                        return point_dic[f].size;
                    },
                    itemStyle: {
                        color: params => {
                            const idx = params.dataIndex;
                            const f = (flags[idx] != null ? flags[idx] : 0);
                            return point_dic[f].color;
                        }
                    }
                },
            ],
            emphasis: {
                disabled: true
            },
            brush: {
                transformable: true,
                toolbox: ['lineX'],
                brushMode: 'single',
                removeOnClick: false,
                xAxisIndex: 0,
                throttleType: 'debounce',
                throttleDelay: 1,
                brushStyle: {
                    color: 'rgba(255, 173, 177, 0.25)',
                    lineWidth: 1,
                    opacity: 0.7,
                },
            },
        };

        chart1.setOption(option1);
        chart2.setOption(option2);


        chart1.getZr().on('click', function (event) {
            const pixel = [event.offsetX, event.offsetY]; // Get the mouse click pixel coordinates
            const point = chart1.convertFromPixel({seriesIndex: 0}, pixel); // Convert to data coordinates
            if (point && !isNaN(point[0])) {
                const dataIndex = Math.round(point[0]); // Calculate the nearest x-axis index
                if (dataIndex >= 0 && dataIndex < fullData.length) {
                    navigateTo(dataIndex);
                }
            }
        });


        window.addEventListener("resize", () => {
            chart1.resize();
            chart2.resize();
            if (norm_a_normal_pattern_chart) norm_a_normal_pattern_chart.resize();
            if (anomalyScoreChart) anomalyScoreChart.resize();
            if (anomalyScoreHistogramChart) anomalyScoreHistogramChart.resize();
        });


        chart2.on("brush", function (params) {
            let areas = params.areas;
            if (areas && areas.length > 0) {
                let newStart = Math.ceil(areas[0].coordRange[0]);
                let newEnd = Math.floor(areas[0].coordRange[1]);

                if (newStart > newEnd) {
                    newStart = newEnd;
                }
                brushAreas[brushAreas.length - 1] = {start: newStart, end: newEnd};
            }
            updateBrushAreas();
        });


        let hideBrushTimeout;
        chart2.on('dataZoom', function (params) {

            const startValue = chart2.getOption().dataZoom[0].startValue;
            const endValue = chart2.getOption().dataZoom[0].endValue;

            chart1.dispatchAction({
                type: 'brush',
                brushId: 'currentWindowBrush',
                areas: [{
                    brushType: 'lineX',
                    xAxisIndex: 0,
                    coordRange: [startValue, endValue]
                }]
            });

            if (hideBrushTimeout) {
                clearTimeout(hideBrushTimeout);
            }

            hideBrushTimeout = setTimeout(() => {
                chart1.dispatchAction({
                    type: 'brush',
                    brushId: 'currentWindowBrush',
                    areas: []
                });
            }, 500);

        });

    }


    // chart1 navigation: navigate to an index
    function navigateTo(index) {
        let start, end;
        switch (clickRangeScale) {
            case 1:
                let zoomRange = brushAreas[brushAreas.length - 1]['end'] - brushAreas[brushAreas.length - 1]['start'];
                zoomRange = Math.round(Math.abs(zoomRange) / 2);
                start = Math.max(0, index - zoomRange);
                end = Math.min(fullData.length - 1, index + zoomRange);

                chart2.dispatchAction({
                    type: "dataZoom",
                    startValue: start,
                    endValue: end,
                });

                document.getElementById("addTrainingSet").click();
                break;

            case 2:
                alert(222)
                start = Math.max(0, index - 500);
                end = Math.min(fullData.length - 1, index + 500);

                chart2.dispatchAction({
                    type: "dataZoom",
                    startValue: start,
                    endValue: end,
                });
                break;

            case 4:
                start = Math.max(0, index - 3.5 * norm_a_l);
                end = Math.min(fullData.length - 1, index + 3.5 * norm_a_l);

                chart2.dispatchAction({
                    type: "dataZoom",
                    startValue: Math.floor(start),
                    endValue: Math.ceil(end),
                });
                break;
        }

    }


    window.onload = () => {
        document.getElementById('showUploadDataModal').click();
    };


    document.getElementById("uploadDatasetBtn").addEventListener("click", () => {
        const select = document.getElementById("exampleDataSelect");
        const selectedValue = select.value;
        if (selectedValue !== "" && selectedValue !== null && !select.options[0].selected) {
            const base = "{{ url_for('static', filename='datasets/') }}";
            const url = base + selectedValue;
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error("Network response was not ok");
                    }
                    return response.text();
                })
                .then(data => {
                    fullData = parseARFF(data);
                    initCharts();
                    enableSelectTrainSetsPhase();
                    const myModalEl = document.getElementById('staticBackdrop');
                    const modalInstance = bootstrap.Modal.getOrCreateInstance(myModalEl);
                    modalInstance.hide();
                })
                .catch(error => {
                    console.error(error);
                });
        } else {
            const fileInput = document.getElementById("localDataInput");
            const file = fileInput.files[0];
            if (!file) {
                alert("Please select an example dataset or upload a local file.");
                return;
            }


            const fileName = file.name.toLowerCase();
            if (!(fileName.endsWith('.arff') || fileName.endsWith('.csv'))) {
                alert("Only .arff and .csv files are supported.");
                return;
            }

            file.text().then(data => {
                if (fileName.endsWith('.arff')) {
                    fullData = parseARFF(data);
                }
                initCharts();
                enableSelectTrainSetsPhase();
                const myModalEl = document.getElementById('staticBackdrop');
                const modalInstance = bootstrap.Modal.getOrCreateInstance(myModalEl);
                modalInstance.hide();
            }).catch(err => {
                alert("Failed to read the file.");
                console.error(err);
            });
        }
    });


    // Parse ARFF with 2 columns in the @data section:
    function parseARFF(text) {
        const lines = text.split(/\r?\n/).map((line) => line.trim());
        let dataSection = false;
        const data = [];

        for (let i = 0; i < lines.length; i++) {
            if (lines[i].toLowerCase().startsWith("@data")) {
                dataSection = true;
                continue;
            }
            if (dataSection && lines[i] && !lines[i].startsWith("%")) {
                const cols = lines[i].split(",");
                if (cols.length >= 2) {
                    const value = parseFloat(cols[0]);
                    const baseValue = parseInt(cols[1]);
                    if (!isNaN(value) && !isNaN(baseValue)) {
                        data.push(value);
                        baseline.push(baseValue);
                    }
                }
            }
        }


        return data;
    }


    function initChart1() {
        const seriesData = [];
        for (let i = 0; i < fullData.length; i++) {
            seriesData.push([i, fullData[i]]);
        }

        if (brushAreas.length === 0) {
            const brushEnd = Math.floor(fullData.length * 0.1);
            brushAreas = [
                {
                    start: 0,
                    end: brushEnd,
                },
            ];
        }

        chart1.setOption({
            title: {
                text: 'Click An Area To Add A Training Set',
            },
            xAxis: {max: fullData.length - 1},
            series: [
                {
                    data: seriesData,
                },
            ],
        });
    }


    function initAnomalyScoreChart() {
        anomalyScoreChart = echarts.init(document.getElementById("scoreChart"));
        let anomalyScores = trainingSet.map(idx => globalScores[idx]);

        let option = {
            renderer: 'canvas',
            devicePixelRatio: window.devicePixelRatio,
            xAxis: {type: 'category', data: trainingSet, name: "index"},
            yAxis: {
                type: 'value',
                name: "Anomaly Score"
            },
            dataZoom: [{type: "inside"}],
            tooltip: {
                trigger: "axis",
                formatter: params => {
                    let p = params[0];
                    return `Index: ${p.axisValue}<br/>Anomaly Score: ${p.data}.toFixed(3)}`;
                }
            },
            series: [{
                type: 'line',
                data: anomalyScores,
                markArea: {
                    itemStyle: {
                        color: 'rgba(255, 173, 177, 0.3)'
                    },
                    data: brushAreas.map(area => [
                        {xAxis: trainingSet.indexOf(area.start)},
                        {xAxis: trainingSet.indexOf(area.end)}
                    ])
                },
                symbol: point_dic[0].symbol,
                symbolSize: point_dic[0].size,
                itemStyle: point_dic[0].color,

            }]
        };

        anomalyScoreChart.setOption(option);
    }


    function updateBrushAreas() {
        brushAreas.sort((a, b) => a.start - b.start);

        const trainingAreas = brushAreas.map((area) => ({
            brushType: "lineX",
            xAxisIndex: 0,
            coordRange: [area.start, area.end],
            transformable: false,
        }));

        chart1.dispatchAction({
            type: "brush",
            brushId: 'trainingBrush',
            areas: trainingAreas,
        });

        for (let i = 0; i < brushAreas.length; i++) {
            const startSpan = document.getElementById(`currentTrainingSetStart${i + 1}`);
            const endSpan = document.getElementById(`currentTrainingSetEnd${i + 1}`);
            if (startSpan) startSpan.innerText = brushAreas[i].start;
            if (endSpan) endSpan.innerText = brushAreas[i].end;
        }
        let idx = brushAreas.length + 1;
        while (true) {
            const startSpan = document.getElementById(`currentTrainingSetStart${idx}`);
            const endSpan = document.getElementById(`currentTrainingSetEnd${idx}`);
            if (!startSpan && !endSpan) break;
            if (startSpan) startSpan.innerText = '';
            if (endSpan) endSpan.innerText = '';
            idx++;
        }
    }


    function updateChart2() {
        let newBrush = brushAreas[brushAreas.length - 1];

        const seriesData2 = [];
        for (let i = 0; i < fullData.length; i++) {
            seriesData2.push([i, fullData[i]]);
        }

        chart2.setOption({
                title: {
                    text: "Training Set: Scroll To Zoom. Drag Edges To Resize.",
                    left: "center",
                },
                xAxis: {
                    min: 0,
                    max: fullData.length - 1,
                },
                series: [
                    {
                        data: seriesData2,
                    },
                ],

            }, {lazyUpdate: true}
        );

        chart2.dispatchAction({
            type: "brush",
            areas: [
                {
                    brushType: 'lineX',
                    xAxisIndex: 0,
                    coordRange: [newBrush.start, newBrush.end],
                },
            ],
        });


        chart2.dispatchAction({
            type: "dataZoom",
            startValue: newBrush.start,
            endValue: (newBrush.end - newBrush.start) * 0.25 + newBrush.end,
        });
    }


    // add training set button
    document.getElementById("addTrainingSet").addEventListener("click", () => {
        const dataZoom = chart2.getOption().dataZoom[0];
        const zoomStart = Math.floor((dataZoom.start / 100) * fullData.length);
        const zoomEnd = Math.ceil((dataZoom.end / 100) * fullData.length) - 1;

        const zoomBrushAreas = brushAreas.filter(area =>
            area.start >= zoomStart && area.end <= zoomEnd
        );

        let newArea;

        if (zoomBrushAreas.length === 0) {
            const zoomRange = zoomEnd - zoomStart + 1;
            const newStart = zoomStart + Math.floor(zoomRange * 0.05);
            const newEnd = zoomEnd - Math.floor(zoomRange * 0.05);

            newArea = {
                start: newStart,
                end: newEnd,
            };
        } else {
            const lastArea = brushAreas[brushAreas.length - 1];
            const newStart = lastArea.end + 1;
            const remaining = fullData.length - newStart;

            if (remaining <= 0) {
                alert("No remaining data to add a new training set.");
                return;
            }

            const previousLength = lastArea.end - lastArea.start;
            let newLength = previousLength;
            if (remaining < previousLength) {
                newLength = Math.max(Math.floor(remaining * 0.2), 1);
            }
            const newEnd = Math.min(newStart + newLength, fullData.length - 1);

            newArea = {
                start: newStart,
                end: newEnd,
            };
        }

        brushAreas.push(newArea);
        updateBrushAreas();
        updateChart2();

        renderTrainingSets();
    });


    function renderTrainingSets(containerId = 'trainDatasetStats') {
        brushAreas.sort((a, b) => a.start - b.start);
        const container = document.getElementById(containerId);
        container.innerHTML = "";

        brushAreas.forEach((area, idx) => {
            const cardBody = document.createElement("div");
            cardBody.className = "card-body p-1";

            const row = document.createElement("div");
            row.className = "d-flex justify-content-between align-items-center fs-4";

            const label = document.createElement("div");
            label.innerHTML = `<strong id="trainingSetLabel${idx + 1}">Training Set${idx + 1}:</strong>`;

            const startDiv = document.createElement("div");
            startDiv.innerHTML = `<strong>Start:</strong> ${area.start}`;

            const endDiv = document.createElement("div");
            endDiv.innerHTML = `<strong>End:</strong> ${area.end}`;

            const btn = document.createElement("button");
            btn.className = "btn btn-danger ms-2";
            btn.id = `removeButton${idx + 1}`;
            btn.innerText = "Remove";
            btn.onclick = function () {
                brushAreas.splice(idx, 1);
                renderTrainingSets(containerId);
                updateBrushAreas();
                updateChart2();
            };

            if (brushAreas.length === 1) {
                btn.disabled = true;
            }

            row.appendChild(label);
            row.appendChild(startDiv);
            row.appendChild(endDiv);
            row.appendChild(btn);

            cardBody.appendChild(row);
            container.appendChild(cardBody);


            if (idx < brushAreas.length - 1) {
                const hr = document.createElement("hr");
                hr.className = "my-2";
                container.appendChild(hr);
            }
        });

        let totalCount = 0;
        brushAreas.forEach(area => {
            totalCount += area.end - area.start + 1;
        });

        document.getElementById('trainingSetRecords').innerText = totalCount.toString();
    }


    document.getElementById('finshSelectTrainingSetBtn').addEventListener("click", () => {
        const isTooShort = brushAreas.some(area => (area.end - area.start + 1) < 3000);
        if (isTooShort) {
            alert('The training set length must be at least 3000');
            return;
        }

        enableMarkAnomaliesPhase();
    })


    // show the overall data and current training dataset
    function enableTotalDataNum() {
        document.getElementById('totalRecords').textContent = fullData.length.toString();
        document.getElementById('totalRecords3').textContent = fullData.length.toString();
        document.getElementById('datasetStats').classList.remove('d-none');
        document.getElementById('trainDatasetStats').classList.remove('d-none');
        document.getElementById('anomalyCount').innerText = '0';
        document.getElementById('trainingSetRecords').innerText = '0';
        document.getElementById('trainingSetRecords3').innerText = '0';
    }

    // hide 'finish select training sets' btn
    function hideFinishSelectTrainingSetsBtn() {
        document.getElementById('finshSelectTrainingSet').classList.add('d-none');
    }

    // rename chart2 title
    function renameChart2Title(title) {
        chart2.setOption({
            title: {
                text: title,
            }
        });
    }

    // rename chart1 title
    function renameChart1Title(title, subtitle) {
        let currentOptions = chart1.getOption();

        chart1.setOption({
            title: {
                text: title,
                subtext: subtitle !== undefined ? subtitle : currentOptions.title[0].subtext
            }
        });
    }


    function setChart2Title(xColor = 'rgba(255,160,0,1)') {
        const chart2Sect = document.getElementById('chart2');
        let title = chart2Sect.querySelector('.chart2-title');
        if (!title) {
            title = document.createElement('div');
            title.className = 'chart2-title';
            title.innerHTML = `<span class="chart2-x" style="color:${xColor}">X</span>：To be Reviewed`;
            chart2Sect.insertBefore(title, chart2Sect.firstChild);
        } else {
            const xSpan = title.querySelector('.chart2-x');
            if (xSpan) xSpan.style.color = xColor;
        }
    }


    function hideLowerPanelSections() {
        document.getElementById("threeMethods").classList.add("d-none");
        document.getElementById("autoDetectSection").classList.add("d-none");
    }


    function setButtonsDisabled(disabled) {
        document.querySelectorAll('.action-btn').forEach(btn => {
            btn.disabled = disabled;
        });
    }


    // update anomalies numbers
    function updateAnomaliesNum() {
        const totalInBrush = fullData.reduce((count, _, i) => count + (isInBrushAreas(i) ? 1 : 0), 0);

        const countAnomalies = flags.reduce((count, value, i) => {
            const isAnomalyFlag = value === 1;
            const inBrush = isInBrushAreas(i);
            return count + (isAnomalyFlag && inBrush ? 1 : 0);
        }, 0);

        const percentage = totalInBrush > 0 ? ((countAnomalies / totalInBrush) * 100).toFixed(4) + '%' : '0.0000%';

        document.getElementById('anomalyCount').textContent = `${countAnomalies} (${percentage})`;
        document.getElementById('userMarkedAnomaliesNum').textContent = `${countAnomalies} (${percentage})`;
    }


    // only keep brush areas
    function updateChartsByBrushAreas() {
        let filteredData = [];
        let xIndices = [];
        for (const area of brushAreas) {
            for (let i = area.start; i <= area.end; i++) {
                if (i >= 0 && i < fullData.length) {
                    filteredData.push([i, fullData[i]]);
                    xIndices.push(i);
                }
            }
        }
        chart1.setOption({
            xAxis: {type: 'category', data: xIndices, name: "index"},
            series: [{
                data: filteredData.map(([i, v]) => v),
                sampling: 'lttb',
                markArea: {
                    itemStyle: {
                        color: 'rgba(255, 173, 177, 0.3)'
                    },
                    data: brushAreas.map(area => [
                        {xAxis: xIndices.indexOf(area.start)},
                        {xAxis: xIndices.indexOf(area.end)}
                    ])
                }
            }]
        });

        chart2.setOption({
            xAxis: {type: 'category', data: xIndices, name: "index"},
            series: [{
                data: filteredData.map(([i, v]) => v),
                markArea: {
                    itemStyle: {
                        color: 'rgba(255, 173, 177, 0.3)'
                    },
                    data: brushAreas.map(area => [
                        {xAxis: xIndices.indexOf(area.start)},
                        {xAxis: xIndices.indexOf(area.end)}
                    ])
                }
            }]
        });

        return xIndices;
    }


    // Mark anomalies and update charts efficiently
    function markAnomalies(anomalies_indexes_list = flags, visibleFlagsChart1 = [0, 1, 2, 3, 4, 5],
                           visibleFlagsChart2 = [0, 1, 2, 3, 4, 5],) {
        const seriesData = fullData.map((value, index) => [index, value]);

        const symbolArray = anomalies_indexes_list.map(flag => point_dic[flag]?.symbol);
        const symbolSizeArray = anomalies_indexes_list.map(flag => point_dic[flag]?.size);
        const colorArray = anomalies_indexes_list.map(flag => point_dic[flag]?.color);

        function updateChart(chart, visibleFlags) {
            chart.setOption({
                series: [
                    {
                        data: seriesData,
                        symbol: (params) => {
                            const idx = params[0];
                            const flag = anomalies_indexes_list[idx];
                            return visibleFlags.includes(flag) ? symbolArray[idx] : point_dic[0].symbol;
                        },
                        symbolSize: (params) => {
                            const idx = params[0];
                            const flag = anomalies_indexes_list[idx];
                            return visibleFlags.includes(flag) ? symbolSizeArray[idx] : point_dic[0].size;
                        },
                        itemStyle: {
                            color: (params) => {
                                const idx = params.dataIndex;
                                const flag = anomalies_indexes_list[idx];
                                return visibleFlags.includes(flag) ? colorArray[idx] : point_dic[0].color;
                            }
                        }
                    },
                ],
            });
        }

        updateChart(chart1, visibleFlagsChart1);
        updateChart(chart2, visibleFlagsChart2);

        updateAnomaliesNum();
    }


    // for add anomaly layer
    function buildBucketAverages(data, chart) {
        const width = chart.getWidth();
        const N = data.length;
        const bucketSize = Math.ceil(N / width);
        const bucketCount = Math.ceil(N / bucketSize);

        const bucketSum = new Float64Array(bucketCount);
        const bucketCountArr = new Uint32Array(bucketCount);

        for (let i = 0; i < N; ++i) {
            const b = Math.floor(i / bucketSize);
            bucketSum[b] += data[i];
            bucketCountArr[b] += 1;
        }

        const bucketAvg = new Float64Array(bucketCount);
        for (let b = 0; b < bucketCount; ++b) {
            bucketAvg[b] = bucketSum[b] / bucketCountArr[b];
        }

        return {bucketSize, bucketAvg};
    }


    // show oranges X on the upper chart
    /**
     * Add a scatter layer of anomalies on top of the existing line series.
     * Assumes the main line is series[0], so we insert the scatter as series[1].
     */
    function addAnomalyLayer(targetChart, fullData, flags, point_num,) {
        const anomalyData = [];
        for (let i = 0; i < fullData.length; ++i) {
            if (flags[i] === point_num) {
                anomalyData.push([i, fullData[i]]);
            }
        }

        const scatterSeries = {
            id: 'anomalyScatter',
            type: 'scatter',
            sampling: 'average',
            data: anomalyData,
            symbol: point_dic[point_num].symbol,
            symbolSize: point_dic[point_num].size,
            itemStyle: {color: point_dic[point_num].color},
            z: 100,
            large: true,
            largeThreshold: 2000,
            hoverAnimation: false,
        };

        targetChart.setOption({
            series: [
                {},
                scatterSeries
            ]
        });
    }


    function isInBrushAreas(index) {
        return brushAreas.some(area => index >= area.start && index <= area.end);
    }


    function hasAtLeast100UserMarkedPointsInTrainingSet() {
        let count = 0;
        for (let i = 0; i < flags.length; i++) {
            if (flags[i] === 1 && isInBrushAreas(i)) {
                count++;
                if (count >= 100) {
                    return true;
                }
            }
        }
        return false;
    }


    // cancel sequential model while using wheel
    function cancelSequentialMode() {
        if (sequentialMode) {
            sequentialMode = false;

            let markSeqBtn = document.getElementById('markSequentialAnomaliesBtn');
            markSeqBtn.textContent = "Mark Anomalies";
            markSeqBtn.classList.remove("btn-outline-dark");
            markSeqBtn.classList.add("btn-outline-danger");


            chart2.getZr().off('mousedown', sequentialHandlers.mousedown);
            chart2.getZr().off('mousemove', sequentialHandlers.mousemove);
            chart2.getZr().off('mouseup', sequentialHandlers.mouseup);
            chart2.setOption({dataZoom: [{type: 'inside', disabled: false}]});
            chart2.setOption({graphic: []});

            chart2.getDom().removeEventListener('wheel', wheelHandler);
        }
    }


    let wheelHandler = function () {
        cancelSequentialMode();
    };


    // toggle sequential mode
    function toggleSequentialMode(buttonId, flagType, fillColor, strokeColor, stack,
                                  chart1Flags = [0, 1, 2, 3, 4], chart2Flags = [0, 1, 2, 3, 4]
    ) {
        let button = document.getElementById(buttonId);
        sequentialMode = false;

        switch (buttonId) {
            case 'markSequentialAnomaliesBtn':
                if (button.classList.contains("btn-outline-danger")) {
                    sequentialMode = true;
                    button.textContent = "Finish Mark Anomalies";
                    button.classList.replace("btn-outline-danger", "btn-outline-dark");
                } else {
                    button.textContent = "Mark Anomalies";
                    button.classList.replace("btn-outline-dark", "btn-outline-danger");
                }
                break;
        }


        if (sequentialHandlers.mousedown) {
            chart2.getZr().off('mousedown', sequentialHandlers.mousedown);
        }
        if (sequentialHandlers.mousemove) {
            chart2.getZr().off('mousemove', sequentialHandlers.mousemove);
        }
        if (sequentialHandlers.mouseup) {
            chart2.getZr().off('mouseup', sequentialHandlers.mouseup);
        }

        if (sequentialMode) {
            chart2.setOption({
                dataZoom: [{type: 'inside', disabled: true}]
            });

            let gridRect = chart2.getModel().getComponent('grid').coordinateSystem._rect;
            let gridLeft = gridRect.x;
            let gridRight = gridRect.x + gridRect.width;
            let gridTop = gridRect.y;
            let gridBottom = gridRect.y + gridRect.height;
            seqGridTop = gridTop;
            seqGridHeight = gridRect.height;

            chart2.getZr().on('mousedown', sequentialHandlers.mousedown = function (e) {
                if (e.offsetX < gridLeft || e.offsetX > gridRight || e.offsetY < gridTop || e.offsetY > gridBottom || !sequentialMode) {
                    return;
                }
                isSeqDragging = true;
                seqDragStart = e.offsetX;
                chart2.setOption({
                    graphic: [{
                        id: 'seqRect',
                        type: 'rect',
                        shape: {x: seqDragStart, y: gridTop, width: 0, height: seqGridHeight},
                        style: {fill: fillColor, stroke: strokeColor, lineWidth: 1}
                    }]
                });
            });

            chart2.getZr().on('mousemove', sequentialHandlers.mousemove = function (e) {
                if (!isSeqDragging) return;
                let currentX = Math.max(gridLeft, Math.min(e.offsetX, gridRight));
                let x = Math.min(seqDragStart, currentX);
                let width = Math.abs(currentX - seqDragStart);
                chart2.setOption({
                    graphic: [{
                        id: 'seqRect',
                        shape: {x: x, y: gridTop, width: width, height: seqGridHeight}
                    }]
                });
            });

            chart2.getZr().on('mouseup', sequentialHandlers.mouseup = function (e) {
                if (!isSeqDragging) return;
                isSeqDragging = false;
                let currentX = Math.max(gridLeft, Math.min(e.offsetX, gridRight));
                let startPixel = Math.min(seqDragStart, currentX);
                let endPixel = Math.max(seqDragStart, currentX);

                let midY = gridTop + seqGridHeight / 2;
                let startCoord = Math.round(chart2.convertFromPixel({seriesIndex: 0}, [startPixel, midY])[0]);
                let endCoord = Math.round(chart2.convertFromPixel({seriesIndex: 0}, [endPixel, midY])[0]);


                chart2.setOption({
                    graphic: [{
                        id: 'seqRect',
                        type: 'rect',
                        shape: {x: -1, y: gridTop, width: 0.0001, height: seqGridHeight},
                        style: {fill: fillColor, stroke: strokeColor, lineWidth: 1}
                    }]
                });

                switch (flagType) {
                    case 1:
                        let changedPoints1 = [];
                        for (let i = startCoord; i <= endCoord; i++) {
                            if (i >= 0 && i < fullData.length && (flags[i] === 0 || flags[i] === 4)) {
                                changedPoints1.push({index: i, prevFlag: flags[i]});
                                flags[i] = flagType;
                            }
                        }
                        if (changedPoints1.length > 0) {
                            stack.push(changedPoints1);
                        }

                        if (currentPhase === 'MarkAnomaliesPhase') {
                            addAnomalyLayer(chart1, fullData, flags, flagType);
                            markAnomalies(flags, [], chart2Flags);
                        }

                        if (hasAtLeast100UserMarkedPointsInTrainingSet()){
                            document.getElementById('autoDetectBtn').click();
                        }

                        break;

                    case 0:
                        let changedPoints0 = [];
                        for (let i = startCoord; i <= endCoord; i++) {
                            if (i >= 0 && i < fullData.length && (flags[i] === 3 || flags[i] === 1)) {
                                changedPoints0.push({index: i, prevFlag: flags[i]});
                                flags[i] = flagType;
                            }
                        }
                        if (changedPoints0.length > 0) {
                            stack.push(changedPoints0);
                        }

                        markAnomalies(flags, chart1Flags, chart2Flags);
                        break;
                }


            });

            // Cancel sequential mode when scrolling the mouse wheel
            chart2.getDom().addEventListener('wheel', wheelHandler, {once: true});

        } else {
            chart2.getZr().off('mousedown', sequentialHandlers.mousedown);
            chart2.getZr().off('mousemove', sequentialHandlers.mousemove);
            chart2.getZr().off('mouseup', sequentialHandlers.mouseup);
            chart2.setOption({dataZoom: [{type: 'inside', disabled: false}]});
            chart2.setOption({graphic: []});
        }
    }


    // mark sequential anomalies
    document.getElementById('markSequentialAnomaliesBtn').addEventListener('click', function () {
        toggleSequentialMode('markSequentialAnomaliesBtn', 1, point_dic[1]['color'], point_dic[1]['color'],
            markingAnomaliesStack, [], [0, 1, 2, 3, 4]
        );
    });


    // mark anomalies redo
    document.getElementById('redoSequentialAnomaliesBtn').addEventListener('click', function () {
        if (markingAnomaliesStack.length > 0) {
            const lastChanges = markingAnomaliesStack.pop();
            for (const change of lastChanges) {
                flags[change.index] = change.prevFlag;
            }
            markAnomalies();
        } else {
            alert("No more sequential anomalies left");
        }
    });


    // after upload the file, then the users should select training sets
    function enableSelectTrainSetsPhase() {
        flags = new Array(fullData.length).fill(0);
        globalScores = new Array(fullData.length).fill(0);
        document.getElementById('finshSelectTrainingSet').classList.remove('d-none');
        document.getElementById('addFinishTrainingSetSection').classList.remove('d-none');
        document.getElementById('trainingSetRecordsText').classList.remove('d-none');
        enableTotalDataNum();
        initChart1();
        updateChart2();
        hideLowerPanelSections();
        document.getElementById('anomalyCountText').classList.add('d-none');
        document.getElementById('markAnomaliesTitle').classList.add('d-none');


        chart2.on("brush", function (params) {
            let areas = params.areas;
            if (areas && areas.length > 0) {
                let newStart = Math.ceil(areas[0].coordRange[0]);
                let newEnd = Math.floor(areas[0].coordRange[1]);

                if (newStart > newEnd) {
                    newStart = newEnd;
                }
                brushAreas[brushAreas.length - 1] = {start: newStart, end: newEnd};
            }
            updateBrushAreas();
            renderTrainingSets();
        });
        sequentialMode = false;
        isSeqDragging = false;

        renderTrainingSets();
    }


    // Mark Anomalies Phase
    function enableMarkAnomaliesPhase() {
        document.getElementById('threeMethods').classList.remove('d-none');
        document.getElementById('autoDetectSection').classList.remove('d-none');
        document.getElementById('markAnomaliesTitle').classList.remove('d-none');
        document.getElementById('finshSelectTrainingSet').classList.add("d-none");
        document.getElementById('addFinishTrainingSetSection').classList.add('d-none');
        document.getElementById('trainDatasetStats').classList.add('d-none');
        document.getElementById('trainingSetRecords').innerText =
            brushAreas.reduce((sum, area) => sum + (area.end - area.start + 1), 0);
        document.getElementById('trainingSetRecords3').innerText =
            brushAreas.reduce((sum, area) => sum + (area.end - area.start + 1), 0);
        document.getElementById('trainingSetRecordsText').classList.remove('d-none');
        document.getElementById('anomalyCountText').classList.remove('d-none');
        renameChart2Title('Detailed Data View');
        currentPhase = 'MarkAnomaliesPhase';
        clickRangeScale = 2;
        renameChart1Title('Click An Area To Navigate');
        trainingSet = updateChartsByBrushAreas();


        chart1.off('brush');
        chart2.off('brush');
        chart1.dispatchAction({
            type: 'brush',
            areas: []
        });
        chart2.dispatchAction({type: "brush", areas: []});


        chart2.dispatchAction({
            type: "dataZoom",
            startValue: brushAreas[0].start,
            endValue: brushAreas[0].end,
        });

    }


    // Revise Potential Mislabeled Anomalies Phase
    function enableRevisePotentialMislabeledAnomaliesPhase() {
        document.getElementById('scoreChart').classList.remove('d-none');
        document.getElementById('threeMethods').classList.add('d-none');
        document.getElementById('datasetStats').classList.add('d-none');
        document.getElementById('autoDetectSection').classList.add('d-none');
        // document.getElementById('datasetStats3').classList.remove('d-none');
        document.getElementById('showNormalPatternArea').classList.remove('d-none');
        document.getElementById('anomalyScoreDistributionHistogramSection').classList.remove('d-none');
        document.getElementById('cancelMislabeledPointsSection').classList.remove('d-none');
        document.getElementById('yesOrNoButtonsSection').classList.remove('d-none');
        document.getElementById('datasetStats4').classList.remove('d-none');
        clickRangeScale = 4;

        document.getElementById('autoDetectSection').classList.remove('mt-4');
        cancelSequentialMode();

        // Change Instruction Content:
        document.getElementById('markAnomaliesTitle').classList.add('d-none');
        renameChart1Title('Full Data Overview', '');


        const chartsWrapper = document.querySelector('.charts-wrapper');
        const scoreChart = document.getElementById('scoreChart');
        const chart1Dom = document.getElementById('chart1');
        const chart2Dom = document.getElementById('chart2');

        chartsWrapper.appendChild(chart2Dom);
        chartsWrapper.appendChild(chart1Dom);
        chartsWrapper.appendChild(scoreChart);

        initAnomalyScoreHistogramChart();
        initAnomalyScoreChart();
        chart2.resize();
        anomalyScoreChart.resize();
        chart1.resize();

        chart1.setOption({
            title: {
                text: 'Time Series'
            },
            dataZoom: [{type: "inside"}],
            series: [
                {
                    sampling: 'lttb',
                },
            ]
        });

        chart2.setOption({
            title: {show: false},
            grid: {left: '5%', right: '5%', top: '20%', bottom: '2%', containLabel: true},
        })

        anomalyScoreChart.setOption({
            title: {
                text: 'Anomaly Score',
                left: "center",
                textStyle: {
                    fontSize: 36,
                    fontWeight: 'bold',
                }
            },
            grid: {left: '5%', right: '5%', top: '15%', bottom: '2%', containLabel: true},
        })

    }


    document.getElementById('algorithmSelect').addEventListener('change', function () {
        document.getElementById('normaSection').classList.add('d-none');
        document.getElementById('sandSection').classList.add('d-none');
        document.getElementById('dampSection').classList.add('d-none');
        if (this.value === '0') {
            document.getElementById('normaSection').classList.remove('d-none');
        } else if (this.value === '1') {
            document.getElementById('sandSection').classList.remove('d-none');
        } else if (this.value === '2') {
            document.getElementById('dampSection').classList.remove('d-none');
        }
    });


    // SAND: auto params button
    document.getElementById('autoSand').addEventListener('change', function () {
        let disabled = this.checked;
        document.getElementById('sandSubsequenceLength').disabled = disabled;
        document.getElementById('sandPatternLength').disabled = disabled;
        document.getElementById('sandK').disabled = disabled;
    });

    // DAMP: auto params button
    document.getElementById('autoDamp').addEventListener('change', function () {
        let disabled = this.checked;
        document.getElementById('dampM').disabled = disabled;
        document.getElementById('dampSpIndex').disabled = disabled;
        document.getElementById('dampXLag').disabled = disabled;
    });


    // =========================↓
    // auto-detect
    document.getElementById('optimizeHyperparametersBtn').addEventListener('click', function () {
        //if (!hasAtLeast100UserMarkedPointsInTrainingSet()) {
        //    alert('Please Mark at Least 100 Points');
        //    return;
        //}

        if (!copied) {
            flagsCopy = flags.slice();
            copied = true;
        } else {
            flags = flagsCopy.slice();
        }

        let patternLength;
        const autoDetectCheckbox = document.getElementById('autoDetectPatternLength');
        if (autoDetectCheckbox.checked) {
            patternLength = -1;
        } else {
            const value = document.getElementById('patternLengthInput').value;
            if (value === '') {
                patternLength = -1;
            } else {
                patternLength = value;
            }
        }

        const currentModal = bootstrap.Modal.getInstance(document.getElementById('autoDetectAnomaliesModal'));
        currentModal.hide();

        const loadingModalElement = document.getElementById('loadingModal');
        const loadingModal = new bootstrap.Modal(loadingModalElement);
        loadingModal.show();

        const progressBar = document.getElementById('loadingProgressBar');
        let progress = 0;
        progressBar.style.width = '0%';
        progressBar.innerText = '0%';

        let interval = setInterval(() => {
            if (progress < 90) {
                progress += 15;
                progressBar.style.width = `${progress}%`;
                progressBar.innerText = `${progress}%`;
            }
        }, 7000);

        const algoSelect = document.getElementById('algorithmSelect').value;
        const url = algorithms_dict[algoSelect]['detect_url'];
        currentAlgorithmName = algorithms_dict[algoSelect]['name'];


        const body = {
            hyperparameters: 0,
            data: fullData,
            flags: flags,
            areas: brushAreas,
            pattern_length: patternLength,
        };

        fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        console.error('Server Error:', text);
                        throw new Error('Server returned an error.');
                    });
                }
                return response.json();
            })
            .then(data => {
                clearInterval(interval);
                progress = 100;
                progressBar.style.width = '100%';
                progressBar.innerText = '100%';

                setTimeout(() => {
                    loadingModal.hide();
                    norm_a_l = data.pattern_length;
                    flags = data.flags;
                    globalScores = data.global_scores;
                    training_set_10th = getTopPercentileValue(10);
                    norm_a_normal_patterns = data.nms;
                    norm_a_weights = data.weights;
                    clickRangeScale = 4;
                    enableRevisePotentialMislabeledAnomaliesPhase();
                    initNormPatternChart();
                    fitUserLabels();
                }, 500);
            })
            .catch(error => {
                clearInterval(interval);
                console.log(error);
                loadingModal.hide();
            });
    });

    // =========================↑


    // fit user labels
    function fitUserLabels() {
        const url = "{{ url_for('detect_anomalies.norm_a_fit_user_labels') }}";
        const body = {
            scores: globalScores,
            flags: flags,
            training_set: brushAreas,
        }
        fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        console.error('Server Error:', text);
                        throw new Error('Server returned an error.');
                    });
                }
                return response.json();
            })
            .then(data => {
                    const stable = data.stable;
                    if (stable === 1) {
                        document.getElementById('finalTestBtn').click();
                        final_mu = data.mu;
                        final_sigma = data.sigma;
                    } else {
                        anomalyMus = data.mu;
                        anomalySigmas = data.sigma;
                        anomalyWeights = data.weights;


                        let minIndex = isPossibleMislabeledPointsExist(training_set_10th);

                        renderAnomalyScoreHistogramChart();

                        // exist mislabeled points
                        if (minIndex !== -1 && process_step === -1) {
                            process_step = 0;
                            checkPossibleMislabeledPoints(minIndex);
                            // update sigma
                            lastSigma = currentSigma;
                            document.getElementById('lastSigma').innerText = currentSigma;
                            const anomalyScores = globalScores.filter((_, idx) => flags[idx] === 1);
                            const mean = anomalyScores.reduce((a, b) => a + b, 0) / anomalyScores.length;
                            const variance = anomalyScores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / anomalyScores.length;
                            currentSigma = Math.sqrt(variance).toFixed(5);
                            document.getElementById('currentSigma').innerText = currentSigma;
                            document.getElementById('pointsToReview').innerText = norm_a_intersect.length.toString();
                            return
                        }

                        process_step = 1;


                        norm_a_intersect = data.intersect;
                        currentSigma = data.active_std.toFixed(5);
                        findNormalPointsClosestToIntersectionIndex(norm_a_intersect, norm_a_intersect[0]);
                    }
                }
            )
            .catch(error => {

            });
    }


    function findNormalPointsClosestToIntersectionIndex(l, minIndex) {
        setChart2Title('rgba(255, 120, 110, 1)');
        l.forEach(idx => {
            flags_for_marking_more_labels[idx] = 4;
        });

        const zoomRange = Math.round(4.5 * norm_a_l);

        chart2.dispatchAction({
            type: "dataZoom",
            startValue: Math.max(0, minIndex - zoomRange),
            endValue: Math.min(fullData.length - 1, minIndex + zoomRange)
        });

        document.querySelector('#cancelMislabeledPointsSection span').style.color = 'rgba(255, 120, 110, 1)';

        markAnomalies(flags_for_marking_more_labels, [], [4]);
        addAnomalyLayer(chart1, fullData, flags_for_marking_more_labels, 4);
        addAnomalyLayer(anomalyScoreChart, globalScores, flags_for_marking_more_labels, 4);

        const left = Math.max(0, minIndex - 10);
        const right = Math.min(fullData.length - 1, minIndex + 10);
        const f = Array.from({length: right - left + 1}, (_, k) => left + k);
        document.getElementById('normalPatternChartTitle').innerText = 'Most Similar User-Marked Anomaly Pattern';

        findSimilarAnomalyPattern(f);

    }


    // mark as anomalies || Confirm Anomalies
    document.getElementById('markAsAnomaliesBtn').addEventListener('click', function () {
        switch (process_step) {
            case 0:
                process_step = 1;
                fitUserLabels();
                break
            case 1:
                for (let i = 0; i < flags_for_marking_more_labels.length; i++) {
                    if (flags_for_marking_more_labels[i] === 4) {
                        flags[i] = 1;
                    }
                }
                updateAnomaliesNum();
                fitUserLabels();
                break
        }
    });


    // keep mislabeled points || Cancel Marked Anomalies
    document.getElementById('keepPointsBtn').addEventListener('click', function () {
        switch (process_step) {
            case 0:
                for (let i = 0; i < flags_for_canceling_marked_labels.length; i++) {
                    if (flags_for_canceling_marked_labels[i] === 3) {
                        flags[i] = 2;
                    }
                }
                fitUserLabels();
                updateAnomaliesNum();
                break
            case 1:
                for (let i = 0; i < norm_a_intersect.length; i++) {
                    flags[norm_a_intersect[i]] = 2;
                }
                updateAnomaliesNum();
                fitUserLabels();
                break

        }
    });


    // check possible mislabeled points
    function checkPossibleMislabeledPoints(minIndex) {
        setChart2Title();
        norm_a_intersect = [];
        const zoomRange = Math.round(4.5 * norm_a_l);

        const min_bound = Math.floor(Math.max(0, minIndex - 0.5 * norm_a_l));
        const max_bound = Math.ceil(Math.min(flags.length - 1, minIndex + 0.5 * norm_a_l));

        flags_for_canceling_marked_labels = flags.map((flag, idx) => {
            if (flag === 1 && idx >= min_bound && idx <= max_bound &&
                globalScores[idx] < training_set_10th &&
                globalScores[idx] <= 1.2 * globalScores[minIndex]) {
                norm_a_intersect.push(idx);
                return 3;
            } else {
                return 0;
            }
        });

        document.querySelector('#cancelMislabeledPointsSection span').style.color = 'rgba(255, 160, 0, 1)';

        chart2.dispatchAction({
            type: "dataZoom",
            startValue: Math.max(0, minIndex - zoomRange),
            endValue: Math.min(fullData.length - 1, minIndex + zoomRange)
        });

        markAnomalies(flags_for_canceling_marked_labels, [], [3]);
        addAnomalyLayer(anomalyScoreChart, globalScores, flags_for_canceling_marked_labels, 3);
        addAnomalyLayer(chart1, fullData, flags_for_canceling_marked_labels, 3);

        document.getElementById('normalPatternChartTitle').innerText = 'Most Similar Normal Pattern';
        ;

        findSimilarNormalPatterns(Math.min(...norm_a_intersect), Math.max(...norm_a_intersect));


    }


    // init norm pattern chart
    function initNormPatternChart() {
        if (!norm_a_normal_pattern_chart) {
            norm_a_normal_pattern_chart = echarts.init(normal_pattern_chart_backDom, null, {
                renderer: 'canvas',
                devicePixelRatio: window.devicePixelRatio
            });
        } else {
            norm_a_normal_pattern_chart.resize();
        }
    }

    // update and render norm chart
    function renderNormalPatternChart(c, np, highlightStartIdx = null, highlightEndIdx = null, highlightColor = null) {
        const xData = np.map((_, i) => i);
        let pieces;

        np = np.map((val, i) => {
            if (
                highlightStartIdx !== null &&
                highlightEndIdx !== null &&
                i >= highlightStartIdx &&
                i <= highlightEndIdx
            ) {
                return {
                    value: val,
                    symbol: 'circle',
                }
            }
            return {
                value: val,
                symbol: 'circle',
            }
        });

        if (highlightStartIdx !== null && highlightEndIdx !== null && highlightEndIdx >= highlightStartIdx) {
            pieces = [
                {lte: highlightStartIdx - 1, color: '#5470C6'},
                {gt: highlightStartIdx - 1, lte: highlightEndIdx - 1, color: highlightColor},
                {gt: highlightEndIdx - 1, color: '#5470C6'}
            ];
        } else {
            pieces = [{color: '#5470C6'}];
        }
        let option = {
            title: {show: false},
            xAxis: {type: "category", data: xData, name: "index"},
            yAxis: {type: "value", name: "Value"},
            dataZoom: [{type: "inside"}],
            tooltip: {
                trigger: "axis",
                formatter: params => {
                    const p = params[0];
                    const value = (typeof p.value === 'number') ? p.value.toFixed(3) : p.value;
                    return `Index: ${p.dataIndex}<br/>Value: ${value}`;
                }
            },
            grid: {left: '2%', right: '10%', top: '10%', bottom: '2%', containLabel: true},
            emphasis: {disabled: true},
            visualMap: {
                show: false,
                dimension: 0,
                pieces: pieces
            },
            series: [{
                type: "line",
                data: np,
                smooth: true,
                showAllSymbol: true
            }]
        };
        c.setOption(option);
    }


    // utils ============================ ↓
    function getMu() {
        const brushScores = globalScores.filter((_, i) => isInBrushAreas(i));
        return brushScores.length > 0
            ? brushScores.reduce((a, b) => a + b, 0) / brushScores.length
            : 0;
    }


    function getSigma(mean) {
        const brushScores = globalScores.filter((_, i) => isInBrushAreas(i));
        const n = brushScores.length;
        if (n === 0) return 0;

        const variance = brushScores.reduce((sum, val) => sum + (val - mean) ** 2, 0) / n;
        return Math.sqrt(variance);
    }

    // When percentile=20, return the "largest top 20% percentile value" (i.e., the 80th percentile).
    function getTopPercentileValue(percentile) {
        percentile = Math.max(0, Math.min(100, percentile));
        const brushScores = globalScores.filter((_, i) => isInBrushAreas(i));
        if (brushScores.length === 0) return 0;

        const sorted = brushScores.slice().sort((a, b) => b - a);

        const truePercentile = percentile;
        const pos = (truePercentile / 100) * (sorted.length - 1);
        const lower = Math.floor(pos);
        const upper = Math.ceil(pos);
        if (lower === upper) return sorted[lower];
        return sorted[lower] + (sorted[upper] - sorted[lower]) * (pos - lower);
    }


    function findSimilarNormalPatterns(startIndex, endIndex) {
        const url = "{{ url_for('detect_anomalies.find_similar_pattern') }}";
        const subArray = fullData.slice(startIndex, endIndex + 1);

        const body = {
            original_seq: subArray,
            norm_a_normal_patterns: norm_a_normal_patterns,
        }

        fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        console.error('Server Error:', text);
                        throw new Error('Server returned an error.');
                    });
                }
                return response.json();
            })
            .then(data => {
                let nm = data.nm;
                let start = data.loc
                renderNormalPatternChart(norm_a_normal_pattern_chart, nm, start, start + norm_a_intersect.length, 'rgba(255, 160, 0, 1)');
            })
            .catch(error => {
            });

    }


    function findSimilarAnomalyPattern(f) {
        const url = "{{ url_for('detect_anomalies.find_similar_anomaly_pattern') }}";

        const body = {
            original_seq: f,
            fullData: fullData,
            flags: flags
        }

        fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        console.error('Server Error:', text);
                        throw new Error('Server returned an error.');
                    });
                }
                return response.json();
            })
            .then(data => {
                let seq = data.seq;
                const targetLen = 7 * norm_a_l;
                const seqLen = seq.length;

                let paddedSeq;
                if (seqLen >= targetLen) {
                    const extra = seqLen - targetLen;
                    const left = Math.floor(extra / 2);
                    paddedSeq = seq.slice(left, left + targetLen);
                } else {
                    const needPad = targetLen - seqLen;
                    const leftPad = Math.floor(needPad / 2);
                    const rightPad = needPad - leftPad;

                    const seqStart = seq[0];
                    const seqEnd = seq[seq.length - 1];

                    paddedSeq = [];
                    for (let i = leftPad; i > 0; i--) {
                        paddedSeq.push(seqStart - i);
                    }
                    paddedSeq = paddedSeq.concat(seq);
                    for (let i = 1; i <= rightPad; i++) {
                        paddedSeq.push(seqEnd + i);
                    }
                }

                const highlightStartIdx = paddedSeq.indexOf(seq[0]);
                const highlightEndIdx = paddedSeq.lastIndexOf(seq[seq.length - 1]) + 1;

                let values = paddedSeq.map(idx => fullData[idx]);

                renderNormalPatternChart(
                    norm_a_normal_pattern_chart,
                    values,
                    highlightStartIdx,
                    highlightEndIdx,
                    'rgba(255, 120, 110, 1)'
                );
            })

            .catch(error => {
                console.log(error);
            });
    }


    function isPossibleMislabeledPointsExist(lowBound) {
        let minScore = Infinity;
        let minIndex = -1;

        for (let i = 0; i < flags.length; i++) {
            if (flags[i] === 1 && globalScores[i] < lowBound) {
                if (globalScores[i] < minScore) {
                    minScore = globalScores[i];
                    minIndex = i;
                }
            }
        }
        return minIndex;
    }

    // utils ============================ ↑


    // anomaly score histogram ============================ ↓
    function initAnomalyScoreHistogramChart() {
        if (!anomalyScoreHistogramChart) {
            anomalyScoreHistogramChart = echarts.init(anomalyScoreHistogramChartDom, null, {
                renderer: 'canvas',
                devicePixelRatio: window.devicePixelRatio
            });
        } else {
            anomalyScoreHistogramChart.resize();
        }
    }


    function renderAnomalyScoreHistogramChart() {
        const anomalyScores = globalScores.filter((_, idx) => flags[idx] === 1);

        if (anomalyScores.length === 0) {
            anomalyScoreHistogramChart.clear();
            anomalyScoreHistogramChart.setOption({
                title: {text: 'No anomalies detected', left: 'center'},
                xAxis: {show: false},
                yAxis: {show: false},
                series: []
            });
            return;
        }

        const minScore = 0;
        const maxScore = 1;
        const binCount = 50;
        const binSize = (maxScore - minScore) / binCount;
        const bins = new Array(binCount).fill(0);

        anomalyScores.forEach(score => {
            let binIdx = Math.floor((score - minScore) / binSize);
            if (binIdx === binCount) binIdx--;
            bins[binIdx]++;
        });

        const xLabels = [];
        const xCenters = [];
        for (let i = 0; i < binCount; i++) {
            const binCenter = minScore + binSize * (i + 0.5);
            xLabels.push(binCenter.toFixed(2));
            xCenters.push(binCenter);
        }

        function gaussianPDF(x, mu, sigma) {
            return 1.0 / (sigma * Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2));
        }

        let densityVals = xCenters.map(x => {
            let sum = 0;
            for (let i = 0; i < anomalyMus.length; ++i) {
                sum += anomalyWeights[i] * gaussianPDF(x, anomalyMus[i], anomalySigmas[i]);
            }
            return sum;
        });

        const maxBin = Math.max(...bins);
        const maxDensity = Math.max(...densityVals);
        const scaleFactor = maxDensity > 0 ? (maxBin / maxDensity) : 1;
        densityVals = densityVals.map(y => y * scaleFactor);

        const series = [
            {
                type: 'bar',
                data: bins,
                itemStyle: {
                    color: 'rgba(255, 120, 110, 1)',
                    borderRadius: 3
                },
                barWidth: '70%',
                name: 'Count'
            },

        ];

        for (let i = 0; i < anomalyMus.length; ++i) {
            const compVals = xCenters.map(
                x => anomalyWeights[i] * gaussianPDF(x, anomalyMus[i], anomalySigmas[i]) * scaleFactor
            );
            series.push({
                type: 'line',
                data: compVals,
                name: `Component ${i + 1}`,
                symbol: 'circle',
                lineStyle: {
                    width: 2,
                    type: 'solid',
                    color: "rgba(255, 0, 0, 0.85)",
                },
                smooth: true,
                z: 8,
                showSymbol: false
            });
        }


        const option = {
            title: {
                text: 'Anomaly Score Distribution (Flag=1)',
                left: 'center'
            },
            tooltip: {
                trigger: 'axis',
                axisPointer: {type: 'shadow'},
                formatter: function (params) {
                    const idx = params[0].dataIndex;
                    const binStart = (minScore + idx * binSize).toFixed(3);
                    const binEnd = (minScore + (idx + 1) * binSize).toFixed(3);
                    let tip = `Score range: [${binStart}, ${binEnd})<br>Count: ${params[0].value}`;
                    if (params.length > 1 && params[1].seriesType === 'line') {
                        tip += `<br>BGMM Density: ${(params[1].value / scaleFactor).toFixed(5)}`;
                    }
                    return tip;
                }
            },
            dataZoom: [{type: "inside"}],
            grid: {left: '8%', right: '6%', bottom: '12%', top: 50},
            xAxis: {
                type: 'category',
                data: xLabels,
                nameLocation: 'center',
                nameGap: 30,
                axisLabel: {rotate: 45}
            },
            yAxis: {
                type: 'value',
                name: 'Count'
            },
            series: series
        };

        anomalyScoreHistogramChart.clear();
        anomalyScoreHistogramChart.setOption(option);
    }


    // anomaly score histogram ============================ ↑


    // final test
    document.getElementById('calculateThresholdBtn').onclick = function () {
        document.getElementById('confidenceSection').classList.add('d-none');
        document.getElementById('evaluationTableSection').classList.remove('d-none');
    };


    document.getElementById('calculateThresholdBtn').addEventListener('click', function () {
        evaluate();
    });


    function evaluate() {
        const alpha = document.getElementById('confidenceInput').value;
        const training_set_miu = getMu();
        const training_set_sigma = getSigma(training_set_miu);

        const threshold = alpha * (final_mu - final_sigma) + (1 - alpha) * Math.min(1,
            training_set_miu + 3 * training_set_sigma);
        const scores = globalScores;
        const groundTruth = baseline;


        let TP = 0, FP = 0, TN = 0, FN = 0;

        for (let i = 0; i < groundTruth.length; i++) {
            if (isInBrushAreas(i)) continue;

            const score = scores[i];
            const predicted = score >= threshold ? 1 : 0;
            const actual = groundTruth[i];


            if (actual === 1 && predicted === 1) TP++;
            else if (actual === 0 && predicted === 1) FP++;
            else if (actual === 0 && predicted === 0) TN++;
            else if (actual === 1 && predicted === 0) FN++;
        }


        const precision = TP + FP === 0 ? 0 : TP / (TP + FP);
        const recall = TP + FN === 0 ? 0 : TP / (TP + FN);
        const f1 = (precision + recall === 0) ? 0 : 2 * precision * recall / (precision + recall);
        const accuracy = (TP + TN + FP + FN === 0) ? 0 : (TP + TN) / (TP + TN + FP + FN);


        document.getElementById('algoName').textContent = currentAlgorithmName;
        document.getElementById('normAPrecisionScore').textContent = precision.toFixed(3);
        document.getElementById('normARecallScore').textContent = recall.toFixed(3);
        document.getElementById('normAf1Score').textContent = f1.toFixed(3);
        document.getElementById('normAAccuracyScore').textContent = accuracy.toFixed(3);
        document.getElementById('finalThreshold').textContent = threshold.toFixed(3);

    }


</script>


</body>
</html>