<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }

        .container-fluid {
            display: flex;
            height: 100vh;
        }

        .charts-wrapper {
            width: 70%;
            display: flex;
            flex-direction: column;
            padding: 0.3%;
        }

        .chart-container1 {
            height: 35%; /* Fixed height for chart1 */
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 1vh;
        }

        .chart-container2 {
            flex-grow: 1; /* Takes remaining space */
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .panel-container {
            width: 30%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 0.3%;
        }

        .panel-section {
            height: 35%; /* Fixed height for the first panel-section */
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 1vh;
            display: flex;
            flex-direction: column;
            overflow: auto;
        }

        .panel-section:last-child {
            flex-grow: 1; /* Takes remaining space, aligning with chart2 */
            height: auto; /* Allow it to expand */
            margin-bottom: 0; /* Remove margin to ensure flush alignment */
        }

        /* Context menu styling ... (unchanged) */
        #contextMenu {
            display: none;
            position: absolute;
            z-index: 9999;
            background: #fff;
            border: 1px solid #ccc;
            min-width: 140px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        }

        #contextMenu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        #contextMenu li {
            padding: 8px 12px;
            cursor: pointer;
        }

        #contextMenu li:hover {
            background: #f1f1f1;
        }
    </style>
</head>
<body>

<div class="container-fluid">
    <!-- Charts Section -->
    <div class="charts-wrapper">
        <div id="chart1" class="chart-container1"></div>
        <div id="chart2" class="chart-container2"></div>
    </div>

    <!-- Right Panel Section -->
    <div class="panel-container">
        <div class="panel-section">
            <!-- Upload Dataset Section -->
            <div class="p-3 bg-light border rounded small text-center d-flex flex-column justify-content-center"
                 id="uploadDatasetSection">
                <h4 class="text-dark fw-bold mb-1">Upload Dataset File: </h4>
                <p class="text-muted mb-2 fs-6">
                    Upload your dataset file in CSV or ARFF format. The system will analyze it and display basic
                    statistics.
                </p>
                <div class="d-flex align-items-center gap-2 p-2">
                    <label for="fileInput" class="form-label fw-semibold my-auto" style="white-space: nowrap;">
                        Choose File:
                    </label>
                    <input type="file" class="form-control flex-grow-1" id="fileInput" accept=".csv, .arff">
                </div>
            </div>


            <!-- Stats section1 -->
            <div id="datasetStats" class="card p-2 mt-1 d-none w-100">
                <div class="card-body p-2">
                    <div class="d-flex justify-content-between">
                        <div><strong>Total Data:</strong> <span class="text-success" id="totalRecords">0</span></div>
                        <div id="trainingSetRecordsText" class="d-none"><strong>TrainingSet:</strong> <span
                                class="text-primary" id="trainingSetRecords">0</span>
                        </div>
                        <div id="anomalyCountText" class="d-none"><strong>Total Possible Anomalies:</strong>
                            <span class="text-danger" id="anomalyCount">0</span>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Stats section2 -->
            <div id="datasetStats2" class="card p-2 mt-1 w-100 d-none">
                <div class="card-body p-2">
                    <div class="d-flex justify-content-between">
                        <div><strong>Marked by User:</strong> <span class="text-success" id="markedByUser">0</span>
                        </div>
                        <div id="possibleMislabeledPoints"><strong>Possible Mislabeled:</strong>
                            <span class="text-warning" id="possibleMislabeledNum">0</span>
                        </div>
                        <div id="tpNumTitle"><strong>TP:</strong>
                            <span class="text-success" id="tpNum">0</span>
                        </div>
                        <div id="fpNumTitle"><strong>FP:</strong>
                            <span class="text-warning" id="fpNum">0</span>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Select Training Set Instruction Box -->
            <div class="p-3 bg-light border rounded small text-center mt-2 d-flex flex-column justify-content-center d-none"
                 id="finshSelectTrainingSet">
                <h4 class="text-dark fw-bold mb-1 fs-3">Select Training Set(s):</h4>
                <p class="text-muted mb-2 fs-6">
                    The top chart is an overview of all the data. The bottom chart zooms in on the currently selected
                    training set.
                </p>
                <button id="finshSelectTrainingSetBtn" class="btn btn-outline-success btn-sm w-50 mx-auto"
                        style="box-shadow: 0 0 8px rgba(40, 167, 69, 0.5);">
                    Finish Selecting Training Set(s)
                </button>
            </div>


            <!-- Revert to Select Training Set Btn -->
            <div class="d-flex gap-2 p-1 w-100 d-none mt-1" id="revertToSelectTrainingSet">
                <button id="revertToSelectTrainingSetBtn" class="btn btn-outline-danger btn-sm w-50"
                        style="box-shadow: 0 0 8px rgba(220, 53, 69, 0.5);">
                    Revert to Select Training Set(s)
                </button>
            </div>


            <!-- Revert to Mark Anomalies Btn -->
            <div class="d-flex gap-2 p-1 w-100 mt-1 d-none" id="revertToMarkAnomalies">
                <button id="revertToMarkAnomaliesBtn" class="btn btn-outline-danger btn-sm w-50"
                        style="box-shadow: 0 0 8px rgba(220, 53, 69, 0.5);">
                    Revert to Mark Anomalies
                </button>
            </div>


            <!-- Mark Anomalies Instruction, Title -->
            <div class="p-3 bg-light border rounded small text-center mt-2 d-flex flex-column justify-content-center d-none"
                 id="markAnomaliesTitle">
                <h3 class="text-dark fw-bold mb-1 fs-3">Mark Anomalies:</h3>
                <p class="text-muted mb-2 fs-6">
                    Use the options below to mark anomalies manually, apply threshold-based marking, mark sequential
                    anomalies,
                    or detect anomalies automatically.
                </p>
                <button id="finshMarkAnomaliesBtn" class="btn btn-outline-success btn-sm w-50 mx-auto"
                        style="box-shadow: 0 0 8px rgba(40, 167, 69, 0.5);">
                    Finish Marking Anomalies
                </button>
            </div>


            <!-- Revise Potential Mislabeled Anomalies Title -->
            <div class="p-3 bg-light border rounded small text-center mt-2 d-flex flex-column justify-content-center d-none"
                 id="revisePotentialMislabeledAnomaliesTitle">
                <h3 class="text-dark fw-bold mb-1 fs-3">Revise Possible Mislabeled Anomalies</h3>
                <p class="text-muted mb-2 fs-6">
                    The following is a list of possible anomalies that are incorrectly labeled.
                </p>
                <button id="finshPotentialMislabeledAnomaliesPhaseBtn"
                        class="btn btn-outline-success btn-sm w-50 mx-auto"
                        style="box-shadow: 0 0 8px rgba(40, 167, 69, 0.5);">
                    Finish Marking Anomalies
                </button>
            </div>


        </div>


        <!-- Lower Panel Section -->
        <div class="panel-section" id="panelSection">

            <!-- Add/Remove Training Set Btn Section -->
            <div class="d-flex gap-1 p-1 w-100">
                <button id="addTrainingSet" class="btn btn-outline-secondary btn-sm w-50 d-none"
                        style="font-size: 1rem">Add A New Training Set
                </button>
                <button id="removeTrainingSet" class="btn btn-outline-secondary btn-sm w-50 d-none"
                        style="font-size: 1rem">Remove Last Training
                    Set
                </button>
            </div>

            <!-- Show Training Set Range Section -->
            <div id="trainDatasetStats" class="card p-1 mt-2 d-none w-100">
                <div class="card-body p-1">
                    <h5 class="text-center mb-2">Training Set Range: </h5>
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <strong id="trainingSetLabel">Training Set1:</strong>
                        </div>
                        <div>
                            <label for="currentTrainingSetStart"><strong>Start:</strong></label>
                            <input type="number" id="currentTrainingSetStart" class="form-control" min="0"
                                   style="width: 100px; display: inline-block;" value="0">
                        </div>
                        <div>
                            <label for="currentTrainingSetEnd"><strong>End:</strong></label>
                            <input type="number" id="currentTrainingSetEnd" class="form-control" max="10000000"
                                   style="width: 100px; display: inline-block;">
                        </div>
                        <button class="btn btn-primary btn-sm ms-2" id="confirmButton">Confirm</button>
                    </div>
                </div>
            </div>


            <!-- Three methods Section -->
            <div class="marking-sections p-2 border border-dark rounded shadow-sm d-none" id="threeMethods">
                <h4 class="text-center mb-3">Manually Mark Anomalies Options:</h4>
                <!-- Section 1: Manual Marking -->
                <div class="p-2 bg-light border rounded small mb-1" id="manualMarkingSection">
                    <p class="text-muted text-center mb-1">
                        <strong>Manual Marking: </strong>Right-click to mark a point as an anomaly
                    </p>
                </div>

                <!-- Section 2: Threshold-Based Marking -->
                <div class="p-2 border rounded small mb-1" id="thresholdMarkingSection">
                    <p class="text-muted mb-2">
                        <strong>Threshold-Based Marking: </strong>Anomalies are points that are above the upper bound
                        or below the lower bound.
                    </p>
                    <div class="d-flex align-items-center mb-1">
                        <label for="anomalyUpperBound" class="form-label mb-0 me-2">Upper Bound:</label>
                        <input type="number" class="form-control form-control-sm me-3" id="anomalyUpperBound"
                               placeholder="Enter upper bound" step="0.001">
                        <label for="anomalyLowerBound" class="form-label mb-0 me-2">Lower Bound:</label>
                        <input type="number" class="form-control form-control-sm" id="anomalyLowerBound"
                               placeholder="Enter lower bound" step="0.001">
                    </div>
                    <div class="text-center">
                        <button id="selectAnomaliesPanelBtn" class="btn btn-outline-primary btn-sm"
                                onclick="thresholdSelect()">Apply
                        </button>
                        <button id="undoThresholdMarkBtn" class="btn btn-outline-danger btn-sm">Undo</button>
                    </div>
                </div>

                <!-- Section 3: Mark Sequential Anomalies -->
                <div class="p-2 bg-light border rounded small d-none" id="sequentialAnomaliesSection">

                    <p class="text-muted text-center mb-1">
                        <strong>Mark Sequential Anomalies: </strong>Click the button below and drag out an area on the
                        chart to mark as sequential anomalies.
                    </p>
                    <div class="text-center">
                        <button id="markSequentialAnomaliesBtn" class="btn btn-outline-primary btn-sm">Mark Sequential
                            Anomalies
                        </button>
                        <button id="redoSequentialAnomaliesBtn" class="btn btn-outline-danger btn-sm">Redo</button>
                    </div>
                </div>
            </div>

            <!-- Mark Normal Section -->
            <div class="p-2 border border-dark rounded shadow-sm mt-4 d-none" id="markAsNormalSection">
                <h4 class="text-center mb-1">Mark Normal Point(s):</h4>
                <p class="text-muted text-center mb-1">
                    Click the button below and drag out an area on the chart to mark as normal points
                </p>
                <div class="text-center">
                    <button id="markNormalPointsBtn" class="btn btn-outline-primary btn-sm">Mark Normal Points</button>
                    <button id="redoSequentialNormalBtn" class="btn btn-outline-danger btn-sm">Redo</button>
                </div>
            </div>


            <!-- Auto detect Section -->
            <div class="p-2 bg-light border border-dark rounded shadow-sm mt-4 text-center d-none"
                 id="autoDetectSection">
                <h4 class="text-center mb-1">Mark Anomalies Automatically:</h4>
                <p class="text-muted text-center mb-1">
                    Automatic marking anomalies
                </p>
                <button id="autoDetectBtn" class="btn btn-outline-primary btn-sm" data-bs-toggle="modal"
                        data-bs-target="#autoDetectAnomaliesModal">Auto Detect
                </button>
                <button id="showAdvancedStatistics" class="btn btn-outline-danger btn-sm d-none" data-bs-toggle="modal"
                        data-bs-target="#scoreDistributionModal">Show Advanced Statistics
                </button>
            </div>


            <!-- Possible Mislabeled Anomalies -->
            <div class="marking-sections p-2 border mt-3 border-dark rounded shadow-sm d-none"
                 id="potentialMislabeledAnomaliesList">
                <h4 class="text-center mb-1">Potential Mislabeled Anomalies Groups</h4>
                <p class="text-center text-muted mb-3" id="potentialMislabeledAnomaliesListText">
                    Orange points represent points that may have been mislabeled, while yellow points are additional
                    anomalies identified by the system based on your current annotations.
                </p>


                <!-- Items: Mislabeled Anomaly -->
                <div class="p-2 bg-light border rounded small mb-1 mislabeled-anomaly-item d-flex
                align-items-center justify-content-between fs-6" id="option1">
                    <div class="me-1">
                        <strong>Group1</strong>
                    </div>
                    <div class="border-start ps-3">

                        <button class="btn btn-outline-danger btn-sm me-2 advanced-stats-btn" id="advancedStatistics1">
                            Advanced
                            Statistics
                        </button>
                        <button class="btn btn-outline-primary btn-sm me-2" id="option1ViewBtn">View</button>
                        <button class="btn btn-outline-success btn-sm accept-mislabeled-btn">Accept</button>
                    </div>
                </div>
            </div>


        </div>

    </div>
</div>

<!-- Custom Right-Click Context Menu -->
<div id="contextMenu">
    <ul id="contextMenuList">
        <li data-anomaly="point">Mark as Point Anomaly</li>
        <li data-anomaly="unknown">Mark as Unknown</li>
        <li data-anomaly="normal">Mark as Normal</li>
    </ul>
</div>


<!-- Auto detect modal -->
<div class="modal fade" id="autoDetectAnomaliesModal" tabindex="-1" aria-labelledby="autoDetectAnomaliesModalLabel"
     aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="autoDetectAnomaliesModalLabel">Auto Detect Anomalies</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>

            <div class="modal-body">
                <!-- Auto-Tune Section -->
                <div class="p-3 mb-3 rounded" style="background-color: #f8f9fa;">
                    <p class="mb-2 text-center">The model automatically tunes hyperparameters based on your labeled
                        anomalies, and this approach is recommended.</p>
                    <div class="text-center">
                        <button id="optimizeHyperparametersBtn" class="btn btn-success">Auto-Tune Hyperparameters
                        </button>
                    </div>
                </div>


            </div>
        </div>
    </div>
</div>


<!-- Progress Bar -->
<div class="modal fade" id="loadingModal" tabindex="-1" aria-hidden="true" data-bs-backdrop="static"
     data-bs-keyboard="false">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content text-center p-5" style="font-size: 1.2rem;">
            <h4 class="mb-4">Calculating...</h4>
            <div class="progress" style="height: 30px;">
                <div id="loadingProgressBar" class="progress-bar progress-bar-striped progress-bar-animated"
                     role="progressbar" style="width: 0%">0%
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Advanced Stats Chart-->
<div class="modal fade" id="scoreDistributionModal" tabindex="-1" aria-labelledby="scoreDistributionModalLabel"
     aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="scoreDistributionModalLabel">Score Distribution</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="scoreDistributionChart" style="height: 500px; width: 100%;"></div>
            </div>
        </div>
    </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"></script>
<script>
    // flags: 0: unknown, 1: anomaly, 2: normal, 3: possible mislabeled points, 4: anomaly marked by system
    let point_dic = {
        0: {'size': 4, 'symbol': 'emptyCircle', 'color': 'rgba(100, 149, 237, 0.8)'},
        1: {'size': 11, 'symbol': 'circle', 'color': 'rgba(255, 30, 0, 0.9)'},
        2: {'size': 9, 'symbol': 'circle', 'color': 'rgba(60, 179, 113, 0.9)'},
        3: {
            'size': 12, 'symbol':
                'image://data:image/svg+xml;utf8,' +
                '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32">' +
                '<line x1="3" y1="3" x2="29" y2="29" ' +
                'stroke="%23FFA000" stroke-width="8" stroke-linecap="round"/>' +
                '<line x1="29" y1="3" x2="3" y2="29" ' +
                'stroke="%23FFA000" stroke-width="8" stroke-linecap="round"/>' +
                '</svg>'
            , 'color': 'rgba(255, 160, 0, 1)'
        },
        4: {'size': 12, 'symbol': 'triangle', 'color': 'rgba(240, 98, 146, 1)'},
    }


    let chart1, chart2;
    let bucketInfo;
    let fullData = [], flags = [], brushAreas = [], baseline = [], globalScores = [];
    let option1_list = [], option2_list = [], option3_list = [], option4_list = [];
    let chart1Title = "Full Data Overview";
    let clickRangeScale = 1;

    let scoreChart = null;
    let _scores = [];

    const modalEl = document.getElementById('scoreDistributionModal');
    const scoreModal = new bootstrap.Modal(modalEl);


    // mark sequential anomalies
    let sequentialMode = false;
    let seqDragStart = null;
    let isSeqDragging = false;
    let sequentialHandlers = {};
    let markingAnomaliesStack = [];
    let markingNormalStack = [];
    let currentPhase = ''; // 'SelectTrainSetsPhase', 'MarkAnomaliesPhase'


    function initCharts() {
        chart1 = echarts.init(document.getElementById("chart1"));
        chart2 = echarts.init(document.getElementById("chart2"));

        let option1 = {
            title: {
                text: "Please click the button on the left panel to upload the data",
                left: "center",
                textStyle: {
                    fontSize: 24,
                    fontWeight: 'bold',
                }
            },
            toolbox: {show: false},
            xAxis: {type: "value", data: [], name: "index"},
            yAxis: {type: "value", data: [], name: "Value"},
            series: [
                {
                    type: "line",
                    data: [],
                    smooth: true,
                    showAllSymbol: true,
                    animation: false,
                    progressive: 5000,
                    progressiveThreshold: 15000,
                    sampling: 'average',
                    symbol: params => {
                        const idx = params.dataIndex;
                        const f = (flags[idx] != null ? flags[idx] : 0);
                        return point_dic[f].symbol;
                    },
                    symbolSize: params => {
                        const idx = params.dataIndex;
                        const f = (flags[idx] != null ? flags[idx] : 0);
                        return point_dic[f].size;
                    },
                    itemStyle: {
                        color: params => {
                            const idx = params.dataIndex;
                            const f = (flags[idx] != null ? flags[idx] : 0);
                            return point_dic[f].color;
                        }
                    }
                },
            ],
            emphasis: {
                disabled: true
            },
            renderer: "canvas",
            brush: [
                {
                    id: 'trainingBrush',
                    xAxisIndex: 0,
                    brushType: 'lineX',
                    brushMode: 'multiple',
                    throttleType: 'debounce',
                    throttleDelay: 1,
                    transformable: false,
                    brushStyle: {
                        color: "rgba(255, 173, 177, 0.3)",
                        lineWidth: 1,
                        opacity: 0.7,
                    },
                },
                {
                    id: 'currentWindowBrush',
                    xAxisIndex: 0,
                    brushType: 'lineX',
                    brushMode: 'single',
                    throttleType: 'debounce',
                    throttleDelay: 1,
                    transformable: false,
                    brushStyle: {
                        color: "rgba(129, 216, 208, 0.7)",
                        lineWidth: 1,
                        opacity: 0.7,
                    },
                }
            ],
        };

        let option2 = {
            title: {
                text: "",
                left: "center",
                textStyle: {
                    fontSize: 24,
                    fontWeight: 'bold',
                },
                subtextStyle: {
                    fontSize: 16,
                }
            },
            toolbox: {show: false},
            xAxis: {type: "value", data: [], name: "index"},
            yAxis: {type: "value", data: [], name: "Value"},
            dataZoom: [{type: "inside"}, {type: "slider"}],
            renderer: "canvas",
            tooltip: {
                trigger: "axis",
                formatter: function (params) {
                    let data = params[0].data;
                    return `Index: ${data[0]}<br>Value: ${data[1]}`;
                }
            },
            series: [
                {
                    type: "line",
                    data: [],
                    smooth: true,
                    showAllSymbol: true,
                    animation: false,
                    sampling: 'lttb',
                    progressive: 5000,
                    progressiveThreshold: 15000,
                    symbol: params => {
                        const idx = params.dataIndex;
                        const f = (flags[idx] != null ? flags[idx] : 0);
                        return point_dic[f].symbol;
                    },
                    symbolSize: params => {
                        const idx = params.dataIndex;
                        const f = (flags[idx] != null ? flags[idx] : 0);
                        return point_dic[f].size;
                    },
                    itemStyle: {
                        color: params => {
                            const idx = params.dataIndex;
                            const f = (flags[idx] != null ? flags[idx] : 0);
                            return point_dic[f].color;
                        }
                    }
                },
            ],
            emphasis: {
                disabled: true
            },
            brush: {
                transformable: true,
                toolbox: ['lineX'],
                brushMode: 'single',
                removeOnClick: false,
                xAxisIndex: 0,
                throttleType: 'debounce',
                throttleDelay: 1,
                brushStyle: {
                    color: 'rgba(255, 173, 177, 0.25)',
                    lineWidth: 1,
                    opacity: 0.7,
                },
            },
        };

        chart1.setOption(option1);
        chart2.setOption(option2);


        chart1.getZr().on('click', function (event) {
            const pixel = [event.offsetX, event.offsetY]; // Get the mouse click pixel coordinates
            const point = chart1.convertFromPixel({seriesIndex: 0}, pixel); // Convert to data coordinates
            if (point && !isNaN(point[0])) {
                const dataIndex = Math.round(point[0]); // Calculate the nearest x-axis index
                if (dataIndex >= 0 && dataIndex < fullData.length) {
                    navigateTo(dataIndex);
                }
            }
        });


        window.addEventListener("resize", () => {
            chart1.resize();
            chart2.resize();
            if (scoreChart) scoreChart.resize();
        });


        chart2.on("brush", function (params) {
            let areas = params.areas;
            if (areas && areas.length > 0) {
                let newStart = Math.ceil(areas[0].coordRange[0]);
                let newEnd = Math.floor(areas[0].coordRange[1]);

                if (newStart > newEnd) {
                    newStart = newEnd;
                }
                brushAreas[brushAreas.length - 1] = {start: newStart, end: newEnd};
            }
            updateBrushAreas();
        });


        let hideBrushTimeout;
        chart2.on('dataZoom', function (params) {

            const startValue = chart2.getOption().dataZoom[0].startValue;
            const endValue = chart2.getOption().dataZoom[0].endValue;

            chart1.dispatchAction({
                type: 'brush',
                brushId: 'currentWindowBrush',
                areas: [{
                    brushType: 'lineX',
                    xAxisIndex: 0,
                    coordRange: [startValue, endValue]
                }]
            });

            if (hideBrushTimeout) {
                clearTimeout(hideBrushTimeout);
            }

            hideBrushTimeout = setTimeout(() => {
                chart1.dispatchAction({
                    type: 'brush',
                    brushId: 'currentWindowBrush',
                    areas: []
                });
            }, 500);

        });

    }


    // chart1 navigation: navigate to an index
    function navigateTo(index) {
        let start, end;
        switch (clickRangeScale) {
            case 1:
                let zoomRange = brushAreas[brushAreas.length - 1]['end'] - brushAreas[brushAreas.length - 1]['start'];
                zoomRange = Math.round(Math.abs(zoomRange) / 2);
                start = Math.max(0, index - zoomRange);
                end = Math.min(fullData.length - 1, index + zoomRange);
                break;

            case 2:
                start = Math.max(0, index - 200);
                end = Math.min(fullData.length - 1, index + 200);
                break;

            default:
                start = Math.max(0, index - 50);
                end = Math.min(fullData.length - 1, index + 50);
        }
        chart2.dispatchAction({
            type: "dataZoom",
            startValue: start,
            endValue: end,
        });
    }


    window.onload = () => {
        initCharts();
    };


    // File input listener
    document.getElementById("fileInput").addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const fileText = await file.text();
        if (file.name.toLowerCase().endsWith(".arff")) {
            fullData = parseARFF(fileText);
        } else {
            alert("Only ARFF parsing shown in this demo.");
            return;
        }

        initCharts();
        flags = [];
        baseline = [];
        brushAreas = [];
        sequentialMode = false;
        seqDragStart = null;
        isSeqDragging = false;
        sequentialHandlers = {};
        markingAnomaliesStack = [];
        markingNormalStack = [];
        currentPhase = '';

        enableSelectTrainSetsPhase();
    });


    // Parse ARFF with 2 columns in the @data section:
    function parseARFF(text) {
        const lines = text.split(/\r?\n/).map((line) => line.trim());
        let dataSection = false;
        const data = [];

        for (let i = 0; i < lines.length; i++) {
            if (lines[i].toLowerCase().startsWith("@data")) {
                dataSection = true;
                continue;
            }
            if (dataSection && lines[i] && !lines[i].startsWith("%")) {
                const cols = lines[i].split(",");
                if (cols.length >= 2) {
                    const value = parseFloat(cols[0]);
                    const baseValue = parseInt(cols[1]);
                    if (!isNaN(value) && !isNaN(baseValue)) {
                        data.push(value);
                        baseline.push(baseValue);
                    }
                }
            }
        }


        return data;
    }


    function initChart1() {
        const seriesData = [];
        for (let i = 0; i < fullData.length; i++) {
            seriesData.push([i, fullData[i]]);
        }

        if (brushAreas.length === 0) {
            const brushEnd = Math.floor(fullData.length * 0.1);
            brushAreas = [
                {
                    start: 0,
                    end: brushEnd,
                },
            ];
        }

        chart1.setOption({
            title: {
                text: chart1Title,
                left: "center",
                subtext: 'Click on an area in the chart to navigate to that area or add it to the training set.',
                subtextStyle: {
                    fontSize: 16,
                }
            },
            xAxis: {max: fullData.length - 1},
            series: [
                {
                    data: seriesData,
                },
            ],
        });
    }


    function updateBrushAreas() {
        const trainingAreas = brushAreas.map((area) => {
            return {
                brushType: "lineX",
                xAxisIndex: 0,
                coordRange: [area.start, area.end],
                transformable: false,
            };
        });

        chart1.dispatchAction({
            type: "brush",
            brushId: 'trainingBrush',
            areas: trainingAreas,
        });


        let lastDic = brushAreas[brushAreas.length - 1];
        let start = lastDic["start"];
        let end = lastDic["end"];
        document.getElementById("currentTrainingSetStart").value = start;
        document.getElementById("currentTrainingSetEnd").value = end;
    }


    function updateChart2() {
        let newBrush = brushAreas[brushAreas.length - 1];

        const seriesData2 = [];
        for (let i = 0; i < fullData.length; i++) {
            seriesData2.push([i, fullData[i]]);
        }

        chart2.setOption({
                title: {
                    text: "Training Set" + brushAreas.length,
                    subtext: 'Use the scrollbar or mouse wheel to navigate. Adjust the brush area by dragging its sides' +
                        ' to resize or moving it to shift the selection',
                    left: "center",
                },
                xAxis: {
                    min: 0,
                    max: fullData.length - 1,
                },
                series: [
                    {
                        data: seriesData2,
                    },
                ],

            }, {lazyUpdate: true}
        );

        chart2.dispatchAction({
            type: "brush",
            areas: [
                {
                    brushType: 'lineX',
                    xAxisIndex: 0,
                    coordRange: [newBrush.start, newBrush.end],
                },
            ],
        });


        chart2.dispatchAction({
            type: "dataZoom",
            startValue: newBrush.start,
            endValue: (newBrush.end - newBrush.start) * 0.25 + newBrush.end,
        });
    }


    // add training set button
    document.getElementById("addTrainingSet").addEventListener("click", () => {
        if (!fullData || fullData.length === 0) return;

        const dataZoom = chart2.getOption().dataZoom[0];
        const zoomStart = Math.floor((dataZoom.start / 100) * fullData.length);
        const zoomEnd = Math.ceil((dataZoom.end / 100) * fullData.length) - 1;

        const zoomBrushAreas = brushAreas.filter(area =>
            area.start >= zoomStart && area.end <= zoomEnd
        );

        let newArea;

        if (zoomBrushAreas.length === 0) {
            const zoomRange = zoomEnd - zoomStart + 1;
            const newStart = zoomStart + Math.floor(zoomRange * 0.05);
            const newEnd = zoomEnd - Math.floor(zoomRange * 0.05);

            newArea = {
                start: newStart,
                end: newEnd,
            };
        } else {
            const lastArea = brushAreas[brushAreas.length - 1];
            const newStart = lastArea.end + 1;
            const remaining = fullData.length - newStart;

            if (remaining <= 0) {
                alert("No remaining data to add a new training set.");
                return;
            }

            const previousLength = lastArea.end - lastArea.start;
            let newLength = previousLength;
            if (remaining < previousLength) {
                newLength = Math.max(Math.floor(remaining * 0.2), 1);
            }
            const newEnd = Math.min(newStart + newLength, fullData.length - 1);

            newArea = {
                start: newStart,
                end: newEnd,
            };
        }

        brushAreas.push(newArea);
        updateBrushAreas();
        updateChart2();
        updateTrainingSetStatisticsTitle(brushAreas.length.toString());
    });


    // confirm button
    document.getElementById('confirmButton').addEventListener("click", () => {
        let newStart = parseFloat(document.getElementById('currentTrainingSetStart').value);
        let newEnd = parseFloat(document.getElementById('currentTrainingSetEnd').value);

        if (newStart >= newEnd || newEnd > fullData.length || newStart < brushAreas[brushAreas.length - 1]['start']) {
            alert('Invalid Input');
            return;
        }

        brushAreas[brushAreas.length - 1] = {
            start: newStart,
            end: newEnd,
        };

        updateBrushAreas();

        const seriesData2 = [];
        for (let i = newStart; i < fullData.length; i++) {
            seriesData2.push([i, fullData[i]]);
        }


        // same as updateChart2
        chart2.setOption({
                title: {
                    text: "Training Set" + brushAreas.length,
                    subtext: 'Use the scrollbar or mouse wheel to navigate. Adjust the brush area by dragging its sides' +
                        ' to resize or moving it to shift the selection',
                    left: "center",
                },
                xAxis: {
                    min: newStart,
                    max: fullData.length - 1,
                },
                series: [
                    {
                        data: seriesData2,
                    },
                ],

            }, {lazyUpdate: true}
        );

        chart2.dispatchAction({
            type: "brush",
            areas: [
                {
                    brushType: 'lineX',
                    xAxisIndex: 0,
                    coordRange: [newStart, newEnd],
                },
            ],
        });

        chart2.dispatchAction({
            type: "dataZoom",
            startValue: newStart,
            endValue: (newEnd - newStart) * 0.25 + newEnd,
        });
    })


    // remove training set button
    document.getElementById("removeTrainingSet").addEventListener("click", () => {
        if (brushAreas.length <= 1) {
            alert("Please keep at least one training set");
            return;
        }
        brushAreas.pop();
        updateBrushAreas();
        updateChart2();
        updateTrainingSetStatisticsTitle(brushAreas.length.toString());
    });


    document.getElementById('finshSelectTrainingSetBtn').addEventListener("click", () => {
        const isTooShort = brushAreas.some(area => (area.end - area.start + 1) < 3000);
        if (isTooShort) {
            alert('The training set length must be at least 3000');
            return;
        }

        enableMarkAnomaliesPhase();
    })


    document.getElementById("revertToSelectTrainingSetBtn").addEventListener("click", () => {
        enableSelectTrainSetsPhase();
    })

    document.getElementById("revertToMarkAnomalies").addEventListener("click", () => {
        enableMarkAnomaliesPhase();
    })


    function enableAddRemoveBtn() {
        let button = document.getElementById("addTrainingSet");

        button.disabled = false;
        button.classList.replace("btn-outline-secondary", "btn-outline-primary");
        button.style.boxShadow = "0 0 8px rgba(0, 123, 255, 0.5)";
        button.classList.remove("d-none");

        let button1 = document.getElementById("removeTrainingSet");
        button1.disabled = false;
        button1.classList.replace("btn-outline-secondary", "btn-outline-danger");
        button1.style.boxShadow = "0 0 8px rgba(220, 53, 69, 0.5)";
        button1.classList.remove("d-none");
    }


    // show the overall data and current training dataset
    function enableTotalDataNum() {
        document.getElementById('totalRecords').textContent = fullData.length.toString();
        document.getElementById('datasetStats').classList.remove('d-none');
        document.getElementById('trainDatasetStats').classList.remove('d-none');
        document.getElementById('anomalyCount').innerText = '0';
        document.getElementById('trainingSetRecords').innerText = '0';
    }

    // show 'finish select training sets' btn
    function enableFinishSelectTrainingSetsBtn() {
        document.getElementById('finshSelectTrainingSet').classList.remove('d-none');
    }

    // hide 'finish select training sets' btn
    function hideFinishSelectTrainingSetsBtn() {
        document.getElementById('finshSelectTrainingSet').classList.add('d-none');
    }

    // hide add/remove btn
    function hideAddRemoveBtn() {
        let button = document.getElementById("addTrainingSet");
        let button1 = document.getElementById("removeTrainingSet");
        button.classList.add('d-none');
        button1.classList.add('d-none');
    }


    // show 'revert to select training sets' btn
    function enableRevertSelectTrainingSetsBtn() {
        document.getElementById('revertToSelectTrainingSet').classList.remove('d-none');
    }

    // hide 'revert to select training sets' btn
    function hideRevertSelectTrainingSetsBtn() {
        document.getElementById('revertToSelectTrainingSet').classList.add('d-none');
    }

    // rename chart2 title
    function renameChart2Title(title, subtitle) {
        let currentOptions = chart2.getOption();

        chart2.setOption({
            title: {
                text: title,
                subtext: subtitle !== undefined ? subtitle : currentOptions.title[0].subtext
            }
        });
    }


    function updateTrainingSetStatisticsTitle(serialNum) {
        document.getElementById('trainingSetLabel').textContent = 'Training Set' + serialNum + ':'
    }


    function showLowerPanelSections() {
        document.getElementById("manualMarkingSection").classList.remove("d-none");
        document.getElementById("thresholdMarkingSection").classList.remove("d-none");
        document.getElementById('sequentialAnomaliesSection').classList.remove("d-none");
    }

    function hideLowerPanelSections() {
        document.getElementById("threeMethods").classList.add("d-none");
        document.getElementById("manualMarkingSection").classList.add("d-none");
        document.getElementById("thresholdMarkingSection").classList.add("d-none");
        document.getElementById("sequentialAnomaliesSection").classList.add("d-none");
        document.getElementById("autoDetectSection").classList.add("d-none");
        document.getElementById("markAsNormalSection").classList.add("d-none");
    }

    function setButtonsDisabled(disabled) {
        document.querySelectorAll('.action-btn').forEach(btn => {
            btn.disabled = disabled;
        });
    }


    // update anomalies numbers
    function updateAnomaliesNum(min_score = -Infinity) {
        const totalInBrush = fullData.reduce((count, _, i) => count + (isInBrushAreas(i) ? 1 : 0), 0);

        const countAnomalies = flags.reduce((count, value, i) => {
            const isAnomalyFlag = value === 1 || value === 3 || value === 4;
            const meetsScore = globalScores[i] >= min_score;
            const inBrush = isInBrushAreas(i);
            return count + (isAnomalyFlag && meetsScore && inBrush ? 1 : 0);
        }, 0);

        const percentage = totalInBrush > 0 ? ((countAnomalies / totalInBrush) * 100).toFixed(4) + '%' : '0.0000%';

        document.getElementById('anomalyCount').textContent = `${countAnomalies} (${percentage})`;
    }


    // Mark anomalies and update charts efficiently
    function markAnomalies(anomalies_indexes_list = flags, visibleFlagsChart1 = [0, 1, 2, 3, 4],
                           visibleFlagsChart2 = [0, 1, 2, 3, 4], min_score = -Infinity) {
        const seriesData = fullData.map((value, index) => [index, value]);

        const symbolArray = anomalies_indexes_list.map(flag => point_dic[flag]?.symbol);
        const symbolSizeArray = anomalies_indexes_list.map(flag => point_dic[flag]?.size);
        const colorArray = anomalies_indexes_list.map(flag => point_dic[flag]?.color);

        function updateChart(chart, visibleFlags) {
            chart.setOption({
                series: [
                    {
                        data: seriesData,
                        symbol: (params) => {
                            const idx = params[0];
                            const flag = anomalies_indexes_list[idx];
                            return visibleFlags.includes(flag) ? symbolArray[idx] : point_dic[0].symbol;
                        },
                        symbolSize: (params) => {
                            const idx = params[0];
                            const flag = anomalies_indexes_list[idx];
                            return visibleFlags.includes(flag) ? symbolSizeArray[idx] : point_dic[0].size;
                        },
                        itemStyle: {
                            color: (params) => {
                                const idx = params.dataIndex;
                                const flag = anomalies_indexes_list[idx];
                                return visibleFlags.includes(flag) ? colorArray[idx] : point_dic[0].color;
                            }
                        }
                    },
                ],
            });
        }

        updateChart(chart1, visibleFlagsChart1);
        updateChart(chart2, visibleFlagsChart2);

        updateAnomaliesNum(min_score);
    }


    function markAnomaliesByMultipleRanges(
        originalFlags,
        scores,
        rangesMap,
        visible1 = [0, 1, 2, 3, 4],
        visible2 = [0, 1, 2, 3, 4], min_score = -Infinity
    ) {
        const flagsToShow = Object.keys(rangesMap).map(k => Number(k));
        const vis1 = Array.isArray(visible1) ? visible1 : flagsToShow;
        const vis2 = Array.isArray(visible2) ? visible2 : flagsToShow;

        const filteredFlags = originalFlags.map((f, i) => {
            const range = rangesMap[f];
            if (range != null && scores[i] >= range.min && scores[i] <= range.max) {
                return f;
            }
            return 0;
        });
        markAnomalies(filteredFlags, vis1, vis2, min_score);
    }


    // for add anomaly layer
    function buildBucketAverages(data, chart) {
        const width = chart.getWidth();
        const N = data.length;
        const bucketSize = Math.ceil(N / width);
        const bucketCount = Math.ceil(N / bucketSize);

        const bucketSum = new Float64Array(bucketCount);
        const bucketCountArr = new Uint32Array(bucketCount);

        for (let i = 0; i < N; ++i) {
            const b = Math.floor(i / bucketSize);
            bucketSum[b] += data[i];
            bucketCountArr[b] += 1;
        }

        const bucketAvg = new Float64Array(bucketCount);
        for (let b = 0; b < bucketCount; ++b) {
            bucketAvg[b] = bucketSum[b] / bucketCountArr[b];
        }

        return {bucketSize, bucketAvg};
    }


    // show oranges X on the upper chart
    /**
     * Add a scatter layer of anomalies on top of the existing line series.
     * Assumes the main line is series[0], so we insert the scatter as series[1].
     */
    function addAnomalyLayer(
        chart, fullData, flags, scores,
        point_num, min_score, max_score,
        bucketInfo
    ) {
        const {bucketSize, bucketAvg} = bucketInfo;

        const anomalyData = [];
        for (let i = 0; i < fullData.length; ++i) {
            if (
                flags[i] === point_num &&
                scores[i] >= min_score &&
                scores[i] <= max_score
            ) {
                const b = Math.floor(i / bucketSize);
                anomalyData.push([i, bucketAvg[b]]);
            }
        }

        const scatterSeries = {
            id: 'anomalyScatter',
            type: 'scatter',
            data: anomalyData,
            symbol: point_dic[point_num].symbol,
            symbolSize: point_dic[point_num].size,
            itemStyle: {color: point_dic[point_num].color},
            z: 100,
            large: true,
            largeThreshold: 2000,
            hoverAnimation: false,
        };

        chart.setOption({
            series: [
                {},
                scatterSeries
            ]
        });
    }


    // handle click
    function handleContextMenuClick(e) {
        const anomalyOption = e.target.getAttribute('data-anomaly');
        if (anomalyOption && currentDataIndex != null) {
            if (anomalyOption === 'unknown') {
                flags[currentDataIndex] = 0;
            } else if (anomalyOption === 'point') {
                flags[currentDataIndex] = 1;
            } else if (anomalyOption === 'normal') {
                flags[currentDataIndex] = 2;
            }

            markAnomalies();
        }
        hideContextMenu();
    }


    function isInBrushAreas(index) {
        return brushAreas.some(area => index >= area.start && index <= area.end);
    }


    // mark by threshold
    function thresholdSelect() {
        let upperBoundValue = document.getElementById("anomalyUpperBound").value;
        upperBoundValue = upperBoundValue === "" ? Infinity : parseFloat(upperBoundValue);
        let lowerBoundValue = document.getElementById("anomalyLowerBound").value;
        lowerBoundValue = lowerBoundValue === "" ? -Infinity : parseFloat(lowerBoundValue);


        for (let i = 0; i < fullData.length; i++) {
            if (isInBrushAreas(i)) {
                if (fullData[i] <= lowerBoundValue || fullData[i] >= upperBoundValue) {
                    flags[i] = 1;
                } else {
                    flags[i] = 0;
                }
            }
        }

        markAnomalies();
    }


    // undo
    document.getElementById('undoThresholdMarkBtn').addEventListener('click', function () {
        let upperBoundValue = Infinity;
        let lowerBoundValue = -Infinity;

        document.getElementById("anomalyUpperBound").value = "";
        document.getElementById("anomalyLowerBound").value = "";


        for (let i = 0; i < fullData.length; i++) {
            if (isInBrushAreas(i)) {
                if (fullData[i] <= lowerBoundValue || fullData[i] >= upperBoundValue) {
                    flags[i] = 1;
                } else {
                    flags[i] = 0;
                }
            }
        }

        markAnomalies();
    })

    // auto-detect
    document.getElementById('optimizeHyperparametersBtn').addEventListener('click', function () {
        const currentModal = bootstrap.Modal.getInstance(document.getElementById('autoDetectAnomaliesModal'));
        currentModal.hide();

        const loadingModalElement = document.getElementById('loadingModal');
        const loadingModal = new bootstrap.Modal(loadingModalElement);
        loadingModal.show();

        const progressBar = document.getElementById('loadingProgressBar');
        let progress = 0;
        progressBar.style.width = '0%';
        progressBar.innerText = '0%';

        let interval = setInterval(() => {
            if (progress < 90) {
                progress += 15;
                progressBar.style.width = `${progress}%`;
                progressBar.innerText = `${progress}%`;
            }
        }, 7000);

        const url = "{{ url_for('detect_anomalies.norm_a') }}";
        const body = {
            hyperparameters: 0,
            data: fullData,
            flags: flags,
            areas: brushAreas,
        };

        fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        console.error('Server Error:', text);
                        throw new Error('Server returned an error.');
                    });
                }
                return response.json();
            })
            .then(data => {
                clearInterval(interval);
                progress = 100;
                progressBar.style.width = '100%';
                progressBar.innerText = '100%';

                setTimeout(() => {
                    loadingModal.hide();
                    flags = data.flags;
                    globalScores = data.global_scores;
                    enableRevisePotentialMislabeledAnomaliesPhase();
                    renderMislabeledGroups(flags, globalScores);
                }, 500);
            })
            .catch(error => {
                clearInterval(interval);
                console.log(error);
                loadingModal.hide();
            });
    });


    // render mislabeled anomalies group
    function renderMislabeledGroups(flags, global_scores) {
        const container = document.getElementById('potentialMislabeledAnomaliesList');
        const template = container.querySelector('.mislabeled-anomaly-item');


        // 1. Find all mislabel indices and sort them by score ascending
        const mislabels = flags
            .map((f, i) => f === 3 ? i : -1)
            .filter(i => i >= 0)
            .sort((a, b) => global_scores[a] - global_scores[b]);

        // 2. Determine how many groups (max 4)
        const groupCount = Math.min(mislabels.length, 4);

        // 3. Clear out old items
        container.querySelectorAll('.mislabeled-anomaly-item').forEach(el => el.remove());

        // 4. Split into groupCount chunks of as-even-as-possible length
        const chunkSizeBase = Math.floor(mislabels.length / groupCount);
        const remainder = mislabels.length % groupCount;
        let cursor = 0;

        for (let gi = 0; gi < groupCount; gi++) {
            const groupNum = gi + 1;
            // distribute the remainder: first `remainder` groups get +1
            const thisSize = chunkSizeBase + (gi < remainder ? 1 : 0);
            const groupIndices = mislabels.slice(cursor, cursor + thisSize);
            cursor += thisSize;

            // compute min/max score for this group
            const groupScores = groupIndices.map(i => global_scores[i]);
            const minScore = Math.min(...groupScores);
            const maxScore = Math.max(...groupScores);

            const minIndexInGroup = groupIndices[groupScores.indexOf(minScore)];

            // clone and customize the template
            const groupEl = template.cloneNode(true);
            groupEl.id = `option${gi + 1}`;
            groupEl.dataset.minScore = minScore;
            groupEl.dataset.maxScore = maxScore;
            groupEl.dataset.lowestIndex = minIndexInGroup;

            // update the displayed title
            const titleEl = groupEl.querySelector('strong');
            if (titleEl) titleEl.textContent = `Group${gi + 1}`;

            // update the View button id
            const viewBtn = groupEl.querySelector('button[id$="ViewBtn"]');

            const min = parseFloat(groupEl.dataset.minScore);
            const max = parseFloat(groupEl.dataset.maxScore);
            const lowestIndex = parseInt(groupEl.dataset.lowestIndex);


            if (viewBtn) {
                viewBtn.id = `option${gi + 1}ViewBtn`;
                viewBtn.addEventListener('click', () => {
                    setButtonsDisabled(true);

                    let chart1Done = false;
                    let chart2Done = false;

                    function checkAllDone() {
                        if (chart1Done && chart2Done) {
                            setButtonsDisabled(false);
                            chart1.off('finished', onChart1Finished);
                            chart2.off('finished', onChart2Finished);
                        }
                    }

                    function onChart1Finished() {
                        chart1Done = true;
                        checkAllDone();
                    }

                    function onChart2Finished() {
                        chart2Done = true;
                        checkAllDone();
                    }

                    chart1.on('finished', onChart1Finished);
                    chart2.on('finished', onChart2Finished);

                    markAnomaliesByMultipleRanges(flags, global_scores, {
                        1: {min: -Infinity, max: Infinity},
                        3: {min: min, max: max},
                        4: {min: min, max: Infinity},
                    }, [0], [0, 1, 2, 3, 4], min);
                    addAnomalyLayer(chart1, fullData, flags, global_scores, 3, min, max, bucketInfo);
                    updateStatsSection2(flags, global_scores, min);


                    chart2.dispatchAction({
                        type: "dataZoom",
                        startValue: Math.max(0, lowestIndex - 20),
                        endValue: Math.min(fullData.length - 1, lowestIndex + 20),
                    });

                });
            }

            const acceptBtn = groupEl.querySelector('.accept-mislabeled-btn');
            if (acceptBtn) {
                acceptBtn.addEventListener('click', () => {
                    // 1. remove this group and all above (1 through groupNum)
                    for (let i = 1; i <= groupNum; i++) {
                        const el = document.getElementById(`option${i}`);
                        if (el) el.remove();
                    }

                    // 2. trigger the next group's ViewBtn
                    const nextViewBtn = document.getElementById(`option${groupNum + 1}ViewBtn`);
                    if (nextViewBtn) {
                        nextViewBtn.click();
                    } else {
                        // no more groups left
                        const ones = flags
                            .map((f, i) => f === 1 ? i : -1)
                            .filter(i => i >= 0);

                        const minScoreFlag1 = ones.length > 0
                            ? Math.min(...ones.map(i => global_scores[i]))
                            : get95thPercentile(global_scores);

                        showNoMoreMislabeledPoints();
                        markAnomaliesByMultipleRanges(flags, global_scores, {
                            1: {min: minScoreFlag1, max: Infinity},
                            4: {min: minScoreFlag1, max: Infinity},
                        }, [0], [0, 1, 2, 3, 4], minScoreFlag1);
                        addAnomalyLayer(chart1, fullData, flags, global_scores, 1, -Infinity, Infinity, bucketInfo);
                        addAnomalyLayer(chart1, fullData, flags, global_scores, 4, minScoreFlag1, Infinity, bucketInfo);

                        updateStatsSection2(flags, global_scores, minScoreFlag1);

                        // zoom out
                        chart2.dispatchAction({
                            type: "dataZoom",
                            startValue: brushAreas[0].start,
                            endValue: brushAreas[0].end,
                        });

                    }
                });
            }


            // append into the container
            container.appendChild(groupEl);
        }


        if (groupCount > 0) {
            const firstViewBtn = document.getElementById('option1ViewBtn');
            if (firstViewBtn) {
                firstViewBtn.click();
            }
        } else {
            showNoMoreMislabeledPoints();
            markAnomalies();
        }
    }


    // update Stats section2 (TP, FP,...)
    function updateStatsSection2(flags, globalScores, min_score) {
        let markedByUser = 0;
        let possibleMislabeled = 0;

        for (let i = 0; i < flags.length; i++) {
            if (globalScores[i] >= min_score) {
                if (flags[i] === 1 || flags[i] === 3) {
                    markedByUser++;
                    if (flags[i] === 3) {
                        possibleMislabeled++;
                    }
                }
            }
        }

        const tp = markedByUser > 0 ? ((markedByUser - possibleMislabeled) / markedByUser) : 0;
        const fp = markedByUser > 0 ? (possibleMislabeled / markedByUser) : 0;

        // Update DOM
        document.getElementById('markedByUser').textContent = markedByUser;
        document.getElementById('possibleMislabeledNum').textContent = possibleMislabeled;
        document.getElementById('tpNum').textContent = `${tp.toFixed(2)} (${markedByUser - possibleMislabeled}/${markedByUser})`;
        document.getElementById('fpNum').textContent = `${fp.toFixed(2)} (${possibleMislabeled}/${markedByUser})`;
    }


    // cancel sequential model
    function cancelSequentialMode() {
        if (sequentialMode) {
            sequentialMode = false;

            let markSeqBtn = document.getElementById('markSequentialAnomaliesBtn');
            markSeqBtn.textContent = "Mark Sequential Anomalies";
            markSeqBtn.classList.remove("btn-outline-success");
            markSeqBtn.classList.add("btn-outline-primary");

            let markNormalBtn = document.getElementById('markNormalPointsBtn');
            markNormalBtn.textContent = "Mark Normal Points";
            markNormalBtn.classList.remove("btn-outline-success");
            markNormalBtn.classList.add("btn-outline-primary");

            chart2.getZr().off('mousedown', sequentialHandlers.mousedown);
            chart2.getZr().off('mousemove', sequentialHandlers.mousemove);
            chart2.getZr().off('mouseup', sequentialHandlers.mouseup);
            chart2.setOption({dataZoom: [{type: 'inside', disabled: false}]});
            chart2.setOption({graphic: []});

            chart2.getDom().removeEventListener('wheel', wheelHandler);
        }
    }


    let wheelHandler = function () {
        cancelSequentialMode();
    };


    // toggle sequential mode
    function toggleSequentialMode(buttonId, flagType, fillColor, strokeColor, stack) {
        let button = document.getElementById(buttonId);
        if (buttonId === 'markSequentialAnomaliesBtn') {
            if (button.classList.contains("btn-outline-primary")) {
                sequentialMode = true;
                let otherButton1 = document.getElementById('markNormalPointsBtn');
                otherButton1.textContent = "Mark Normal Points";
                otherButton1.classList.remove("btn-outline-success");
                otherButton1.classList.add("btn-outline-primary");
                button.textContent = "Finish Mark Sequential Anomalies";
                button.classList.remove("btn-outline-primary");
                button.classList.add("btn-outline-success");
            } else {
                sequentialMode = false;
                button.textContent = "Mark Sequential Anomalies";
                button.classList.remove("btn-outline-success");
                button.classList.add("btn-outline-primary");
            }
        } else if (buttonId === 'markNormalPointsBtn') {
            if (button.classList.contains("btn-outline-primary")) {
                sequentialMode = true;
                let otherButton1 = document.getElementById('markSequentialAnomaliesBtn');
                otherButton1.textContent = "Mark Sequential Anomalies";
                otherButton1.classList.remove("btn-outline-success");
                otherButton1.classList.add("btn-outline-primary");
                button.textContent = "Finish Mark Normal Points";
                button.classList.remove("btn-outline-primary");
                button.classList.add("btn-outline-success");
            } else {
                sequentialMode = false;
                button.textContent = "Mark Normal Points";
                button.classList.remove("btn-outline-success");
                button.classList.add("btn-outline-primary");
            }
        }


        if (sequentialHandlers.mousedown) {
            chart2.getZr().off('mousedown', sequentialHandlers.mousedown);
        }
        if (sequentialHandlers.mousemove) {
            chart2.getZr().off('mousemove', sequentialHandlers.mousemove);
        }
        if (sequentialHandlers.mouseup) {
            chart2.getZr().off('mouseup', sequentialHandlers.mouseup);
        }

        if (sequentialMode) {
            chart2.setOption({
                dataZoom: [{type: 'inside', disabled: true}]
            });

            let gridRect = chart2.getModel().getComponent('grid').coordinateSystem._rect;
            let gridLeft = gridRect.x;
            let gridRight = gridRect.x + gridRect.width;
            let gridTop = gridRect.y;
            let gridBottom = gridRect.y + gridRect.height;
            seqGridTop = gridTop;
            seqGridHeight = gridRect.height;

            chart2.getZr().on('mousedown', sequentialHandlers.mousedown = function (e) {
                if (e.offsetX < gridLeft || e.offsetX > gridRight || e.offsetY < gridTop || e.offsetY > gridBottom || !sequentialMode) {
                    return;
                }
                isSeqDragging = true;
                seqDragStart = e.offsetX;
                chart2.setOption({
                    graphic: [{
                        id: 'seqRect',
                        type: 'rect',
                        shape: {x: seqDragStart, y: gridTop, width: 0, height: seqGridHeight},
                        style: {fill: fillColor, stroke: strokeColor, lineWidth: 1}
                    }]
                });
            });

            chart2.getZr().on('mousemove', sequentialHandlers.mousemove = function (e) {
                if (!isSeqDragging) return;
                let currentX = Math.max(gridLeft, Math.min(e.offsetX, gridRight));
                let x = Math.min(seqDragStart, currentX);
                let width = Math.abs(currentX - seqDragStart);
                chart2.setOption({
                    graphic: [{
                        id: 'seqRect',
                        shape: {x: x, y: gridTop, width: width, height: seqGridHeight}
                    }]
                });
            });

            chart2.getZr().on('mouseup', sequentialHandlers.mouseup = function (e) {
                if (!isSeqDragging) return;
                isSeqDragging = false;
                let currentX = Math.max(gridLeft, Math.min(e.offsetX, gridRight));
                let startPixel = Math.min(seqDragStart, currentX);
                let endPixel = Math.max(seqDragStart, currentX);

                let midY = gridTop + seqGridHeight / 2;
                let startCoord = Math.round(chart2.convertFromPixel({seriesIndex: 0}, [startPixel, midY])[0]);
                let endCoord = Math.round(chart2.convertFromPixel({seriesIndex: 0}, [endPixel, midY])[0]);

                for (let i = startCoord; i <= endCoord; i++) {
                    if (i >= 0 && i < fullData.length) {
                        flags[i] = flagType;
                    }
                }

                chart2.setOption({
                    graphic: [{
                        id: 'seqRect',
                        type: 'rect',
                        shape: {x: -1, y: gridTop, width: 0.0001, height: seqGridHeight},
                        style: {fill: fillColor, stroke: strokeColor, lineWidth: 1}
                    }]
                });

                stack.push({start: startCoord, end: endCoord});
                markAnomalies();
            });

            // Cancel sequential mode when scrolling the mouse wheel
            chart2.getDom().addEventListener('wheel', wheelHandler, {once: true});

        } else {
            chart2.getZr().off('mousedown', sequentialHandlers.mousedown);
            chart2.getZr().off('mousemove', sequentialHandlers.mousemove);
            chart2.getZr().off('mouseup', sequentialHandlers.mouseup);
            chart2.setOption({dataZoom: [{type: 'inside', disabled: false}]});
            chart2.setOption({graphic: []});
        }
    }


    // mark sequential anomalies
    document.getElementById('markSequentialAnomaliesBtn').addEventListener('click', function () {
        toggleSequentialMode('markSequentialAnomaliesBtn', 1, point_dic[3]['color'], 'orange', markingAnomaliesStack);
    });


    // mark anomalies redo
    document.getElementById('redoSequentialAnomaliesBtn').addEventListener('click', function () {
        if (markingAnomaliesStack.length > 0) {
            const lastMark = markingAnomaliesStack.pop();
            for (let i = lastMark.start; i <= lastMark.end; i++) {
                if (i >= 0 && i < fullData.length) {
                    flags[i] = 0;
                }
            }
            markAnomalies();
        } else {
            alert("No more sequential anomalies left");
        }
    });


    // mark normal points
    document.getElementById('markNormalPointsBtn').addEventListener('click', function () {
        toggleSequentialMode('markNormalPointsBtn', 2, point_dic[2]['color'], 'green', markingNormalStack);
    });


    // mark normal redo
    document.getElementById('redoSequentialNormalBtn').addEventListener('click', function () {
        if (markingNormalStack.length > 0) {
            const lastMark = markingNormalStack.pop();
            for (let i = lastMark.start; i <= lastMark.end; i++) {
                if (i >= 0 && i < fullData.length) {
                    flags[i] = 0;
                }
            }
            markAnomalies();
        } else {
            alert("No more normal points left");
        }
    });


    // after upload the file, then the users should select training sets
    function enableSelectTrainSetsPhase() {
        document.getElementById('uploadDatasetSection').classList.add('d-none');
        flags = new Array(fullData.length).fill(0);
        globalScores = new Array(fullData.length).fill(0);
        enableAddRemoveBtn();
        enableTotalDataNum();
        enableFinishSelectTrainingSetsBtn();
        initChart1();
        updateBrushAreas();
        updateChart2();
        hideRevertSelectTrainingSetsBtn();
        hideLowerPanelSections();
        document.getElementById('trainingSetRecordsText').classList.add('d-none');
        document.getElementById('anomalyCountText').classList.add('d-none');
        document.getElementById('markAnomaliesTitle').classList.add('d-none');
        currentPhase = 'SelectTrainSetsPhase';


        chart2.on("brush", function (params) {
            let areas = params.areas;
            if (areas && areas.length > 0) {
                let newStart = Math.ceil(areas[0].coordRange[0]);
                let newEnd = Math.floor(areas[0].coordRange[1]);

                if (newStart > newEnd) {
                    newStart = newEnd;
                }
                brushAreas[brushAreas.length - 1] = {start: newStart, end: newEnd};
            }
            updateBrushAreas();
        });


        chart2.getZr().off('contextmenu');
        document.getElementById('contextMenuList').removeEventListener('click', handleContextMenuClick);
        document.removeEventListener('click', hideContextMenu);
        hideContextMenu();

        sequentialMode = false;
        isSeqDragging = false;
    }


    // Show custom context menu at mouse position
    function showContextMenu(evt) {
        const menu = document.getElementById('contextMenu');
        menu.style.display = 'block';
        menu.style.left = evt.pageX + 'px';
        menu.style.top = evt.pageY + 'px';
    }

    // Hide context menu
    function hideContextMenu() {
        document.getElementById('contextMenu').style.display = 'none';
    }


    // show No More Mislabeled Points texts
    function showNoMoreMislabeledPoints() {
        document.getElementById('potentialMislabeledAnomaliesListText').innerText =
            'There are no points that might be wrongly marked.';
    }


    // get 95th percentile number of a list
    function get95thPercentile(scores) {
        if (!scores.length) return null;

        const sorted = [...scores].sort((a, b) => a - b);

        const index = 0.95 * (sorted.length - 1);
        const lower = Math.floor(index);
        const upper = Math.ceil(index);

        if (lower === upper) {
            return sorted[lower];
        } else {
            const weight = index - lower;
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }
    }


    // show score distribution histogram after model has shown
    modalEl.addEventListener('shown.bs.modal', () => {
        const dom = document.getElementById('scoreDistributionChart');
        if (!scoreChart) {
            scoreChart = echarts.init(dom, null, {
                renderer: 'canvas',
                devicePixelRatio: window.devicePixelRatio
            });
        } else {
            scoreChart.resize();
        }
        renderScoreDistribution(scoreChart, _scores);
    });

    modalEl.addEventListener('hidden.bs.modal', () => {
        document.body.classList.remove('modal-open');
        document.querySelectorAll('.modal-backdrop').forEach(el => el.remove());
    });


    // show modal
    function showScoreDistributionModal(scores) {
        _scores = scores.slice();
        const modal = new bootstrap.Modal(
            document.getElementById('scoreDistributionModal')
        );
        modal.show();
    }


    function renderScoreDistribution(chart, scores) {
    // pick only scores whose index falls in any brush area
    const filtered = brushAreas && brushAreas.length
        ? scores.filter((s, i) => brushAreas.some(area => i >= area.start && i <= area.end))
        : scores;

    const binCount = 100;
    let min = Infinity, max = -Infinity;
    // find min/max among filtered values
    filtered.forEach(s => {
        if (s < min) min = s;
        if (s > max) max = s;
    });

    const binSize = (max - min) / binCount;
    const bins = new Array(binCount).fill(0);
    // tally into bins
    filtered.forEach(score => {
        const idx = Math.min(Math.floor((score - min) / binSize), binCount - 1);
        bins[idx]++;
    });

    // generate category labels
    const binLabels = Array.from({ length: binCount }, (_, i) =>
        (min + i * binSize).toFixed(2)
    );

    chart.setOption({
        title: { text: 'Score Distribution', left: 'center' },
        tooltip: {},
        xAxis: {
            type: 'category',
            data: binLabels,
            name: 'Score Range',
            axisLabel: { interval: Math.ceil(binCount / 20), rotate: 45 }
        },
        yAxis: { type: 'value', name: 'Frequency' },
        series: [{
            type: 'bar',
            data: bins,
            barMaxWidth: 10
        }]
    });
}


    // show advanced score distribution btn
    document.getElementById('showAdvancedStatistics').addEventListener('click', function () {
        showScoreDistributionModal(globalScores);
    })


    // Mark Anomalies Phase
    function enableMarkAnomaliesPhase() {
        bucketInfo = buildBucketAverages(fullData, chart1);
        document.getElementById('threeMethods').classList.remove('d-none');
        document.getElementById('autoDetectSection').classList.remove('d-none');
        document.getElementById('markAsNormalSection').classList.remove('d-none');
        document.getElementById('markAnomaliesTitle').classList.remove('d-none');
        document.getElementById('finshSelectTrainingSet').classList.add("d-none");
        document.getElementById('trainDatasetStats').classList.add('d-none');
        document.getElementById('potentialMislabeledAnomaliesList').classList.add('d-none');
        document.getElementById('revisePotentialMislabeledAnomaliesTitle').classList.add('d-none');
        document.getElementById('trainingSetRecords').innerText =
            brushAreas.reduce((sum, area) => sum + (area.end - area.start + 1), 0);
        document.getElementById('trainingSetRecordsText').classList.remove('d-none');
        document.getElementById('anomalyCountText').classList.remove('d-none');
        hideAddRemoveBtn();
        enableRevertSelectTrainingSetsBtn();
        renameChart2Title('Mark Anomalies', 'Use the scrollbar or mouse wheel to navigate.');
        showLowerPanelSections();
        currentPhase = 'MarkAnomaliesPhase';


        const seriesDataFull = [];
        for (let i = 0; i < fullData.length; i++) {
            seriesDataFull.push([i, fullData[i]]);
        }
        chart2.setOption({
            xAxis: {min: 0, max: fullData.length - 1,},
            series: [{data: seriesDataFull}]
        },);

        chart2.off('brush');

        const areas = brushAreas.map((area) => {
            return {
                brushType: "lineX",
                xAxisIndex: 0,
                coordRange: [area.start, area.end],
                transformable: false,
                brushMode: "multiple",
            };
        });

        chart2.dispatchAction({type: "brush", areas: areas});


        chart2.dispatchAction({
            type: "dataZoom",
            startValue: brushAreas[0].start,
            endValue: brushAreas[0].end,
        });


        // manual mark
        chart2.getZr().on('contextmenu', function (event) {
            // Prevent the browser's default context menu
            event.event.preventDefault();


            const pixel = [event.offsetX, event.offsetY];
            const point = chart2.convertFromPixel({seriesIndex: 0}, pixel);

            if (point && !isNaN(point[0])) {
                const dataIndex = Math.round(point[0]);

                // Check bounds just to be safe
                if (dataIndex >= 0 && dataIndex < fullData.length) {
                    currentDataIndex = dataIndex;
                    showContextMenu(event.event);
                }
            }

        });


        // Context menu list clicks
        document.getElementById('contextMenuList').addEventListener('click', handleContextMenuClick);

        // Hide context menu on any click outside
        document.addEventListener('click', function () {
            hideContextMenu();
        });

    }


    // Revise Potential Mislabeled Anomalies Phase
    function enableRevisePotentialMislabeledAnomaliesPhase() {
        document.getElementById('threeMethods').classList.add('d-none');
        document.getElementById('markAsNormalSection').classList.add('d-none');
        document.getElementById('revertToSelectTrainingSetBtn').classList.add('d-none');
        // document.getElementById('revertToMarkAnomalies').classList.remove('d-none');
        document.getElementById('potentialMislabeledAnomaliesList').classList.remove('d-none');
        document.getElementById('showAdvancedStatistics').classList.remove('d-none');
        document.getElementById('datasetStats2').classList.remove('d-none');
        clickRangeScale = 2;

        document.getElementById('autoDetectSection').classList.remove('mt-4');
        cancelSequentialMode();

        // Change Instruction Content:
        document.getElementById('markAnomaliesTitle').classList.add('d-none');
        document.getElementById('revisePotentialMislabeledAnomaliesTitle').classList.remove('d-none');


    }


</script>


</body>
</html>